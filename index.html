<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>WindHouse - Tank Battle (v64.0 - UI & Mechanic Mod)</title>
    <style>
        /* --- CSS C·ªêT L√ïI & RESPONSIVE --- */
        body { 
            margin: 0; background-color: #050505; 
            font-family: 'Segoe UI', 'Arial Black', sans-serif; 
            height: 100vh; height: 100dvh; width: 100vw;
            user-select: none; overflow: hidden; touch-action: none; 
            position: fixed; top: 0; left: 0;
            -webkit-tap-highlight-color: transparent;
        }

        /* M√ÄN H√åNH Y√äU C·∫¶U XOAY */
        #rotateOverlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999;
            flex-direction: column; align-items: center; justify-content: center;
            color: #fff; text-align: center;
        }
        .rotate-icon { font-size: 60px; margin-bottom: 20px; animation: spin 2s infinite linear; }
        @keyframes spin { 100% { transform: rotate(90deg); } }

        @media screen and (orientation: portrait) {
            #rotateOverlay { display: flex; }
            #gameWrapper, #menuOverlay, #mobileControls { display: none !important; }
        }

        /* KHUNG GAME CH√çNH */
        #gameWrapper { 
            position: relative; background: #111; 
            aspect-ratio: 1365 / 860; width: min(95vw, calc(95vh * (1365 / 860)));
            margin: auto; border: 4px solid #333; border-radius: 4px; 
            display: flex; flex-direction: column; box-shadow: 0 0 80px rgba(0,0,0,0.8);
        }

        @media screen and (max-width: 920px) and (orientation: landscape) {
            #gameWrapper {
                width: 100vw !important; height: 100dvh !important; 
                border: none !important; border-radius: 0 !important;
                margin: 0 !important; box-shadow: none !important;
            }
            .btn-group { margin-bottom: 20px; transform: scale(1.1) !important; }
            .controls-container { transform: scale(0.65); margin-bottom: 5px; } 
            h1.game-title { font-size: 8vh; }
        }

        #canvasContainer {
            position: relative; flex: 1; width: 100%; height: 100%;
            background-color: #ececec; overflow: hidden;
            display: flex; justify-content: center; align-items: center;
        }

        canvas { display: block; position: absolute; width: 100%; height: 100%; object-fit: contain; }
        #bgCanvas { z-index: 1; }
        #gameCanvas { z-index: 2; cursor: crosshair; background: transparent; }
        
        /* --- UI LAYER --- */
        #menuOverlay, #guideModal, #settingsModal, #modeSelectModal, #deviceSelectModal, #aiAdviceModal { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            z-index: 100; color: #fff; pointer-events: auto;
        }
        #menuOverlay { background: radial-gradient(circle at center, rgba(20,20,20,0.95) 0%, rgba(5,5,5,0.98) 100%); z-index: 300; }
        #settingsModal, #guideModal, #modeSelectModal, #aiAdviceModal { display: none; background: rgba(0,0,0,0.96); z-index: 400; }
        #deviceSelectModal { z-index: 500; background: #000; }

        /* MENU ELEMENTS */
        .main-title-box { text-align: center; margin-bottom: 1vh; z-index: 2; position: relative; } 
        .title-prefix { font-size: 1.5vh; font-weight: 900; color: #666; letter-spacing: 12px; text-transform: uppercase; display: block; }
        h1.game-title { font-family: 'Arial Black', sans-serif; font-size: 8vh; margin: 0; text-transform: uppercase; letter-spacing: -4px; color: #fff; text-shadow: 0 10px 30px rgba(0,0,0,0.8); background: linear-gradient(180deg, #fff 0%, #aaa 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        .controls-container { display: flex; gap: 40px; margin-bottom: 2vh; z-index: 2; transform: scale(0.85); transform-origin: center top; }
        .player-card-ui { 
            background: rgba(20, 20, 20, 0.6); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); 
            padding: 20px; width: 200px; text-align: center; position: relative;
            box-shadow: 0 20px 40px rgba(0,0,0,0.4); clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
        }
        .player-card-ui.p1 { border-top: 4px solid #2e7d32; } .player-card-ui.p1 .p-label { color: #66bb6a; }
        .player-card-ui.p2 { border-top: 4px solid #c62828; } .player-card-ui.p2 .p-label { color: #ef5350; }
        .p-label { font-size: 16px; font-weight: 900; margin-bottom: 10px; display: block; letter-spacing: 3px; text-transform: uppercase; }
        .ctrl-row { margin: 5px 0; font-size: 11px; color: #aaa; display: flex; align-items: center; justify-content: center; gap: 5px; font-weight: bold; text-transform: uppercase; }
        .key-cap { background: #151515; border: 1px solid #333; border-bottom: 3px solid #333; border-radius: 4px; padding: 2px 6px; font-family: monospace; font-weight: bold; font-size: 12px; color: #fff; min-width: 20px; display: inline-block; }

        .btn-group { display: flex; gap: 20px; justify-content: center; z-index: 2; transform: scale(0.9); margin-top: 10px; }
        .btn-main { padding: 15px 40px; font-size: 18px; font-family: 'Arial Black', sans-serif; text-transform: uppercase; border: none; cursor: pointer; transition: all 0.2s; position: relative; letter-spacing: 2px; clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px); touch-action: manipulation; }
        .btn-start { background: linear-gradient(135deg, #d32f2f, #9a0007); color: white; text-shadow: 0 2px 0 rgba(0,0,0,0.3); }
        .btn-guide { background: transparent; color: #888; border: 2px solid #333; font-size: 16px; padding: 15px 30px; }

        /* --- MOBILE CONTROLS --- */
        #mobileControls { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 80; display: none; pointer-events: none; }
        
        .control-set { 
            position: absolute; top: 0; bottom: 0; width: 120px; 
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            gap: 30px; pointer-events: none; transform-origin: center center;
        }
        .control-set.swapped { flex-direction: column-reverse; }
        .control-set.p1-set { left: 10px; }
        .control-set.p2-set { right: 10px; }

        .touch-zone { 
            width: 110px; height: 110px; background: rgba(0, 0, 0, 0.05); 
            border-radius: 50%; border: 2px solid rgba(0,0,0,0.15); 
            position: relative; margin: 0; touch-action: none; pointer-events: auto; 
        }
        .stick-knob { 
            width: 50px; height: 50px; background: rgba(0, 0, 0, 0.3); 
            border-radius: 50%; position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); pointer-events: none; 
        }
        
        .fire-btn { 
            width: 70px; height: 70px; border-radius: 50%; border: 2px solid rgba(0,0,0,0.15); 
            display: flex; justify-content: center; align-items: center; 
            font-weight: bold; color: rgba(0,0,0,0.5); font-size: 12px; margin: 0;
            background: rgba(0,0,0,0.05); touch-action: none; user-select: none; cursor: pointer; pointer-events: auto; 
        }
        
        .p1-set .touch-zone { border-color: rgba(46, 125, 50, 0.4); } 
        .p1-set .stick-knob { background: rgba(46, 125, 50, 0.5); } 
        .p1-set .fire-btn { border-color: rgba(46, 125, 50, 0.4); color: #2e7d32; } 
        .p1-set .fire-btn:active { background: rgba(46, 125, 50, 0.6); color:#fff; transform: scale(0.95); }

        .p2-set .touch-zone { border-color: rgba(198, 40, 40, 0.4); } 
        .p2-set .stick-knob { background: rgba(198, 40, 40, 0.5); } 
        .p2-set .fire-btn { border-color: rgba(198, 40, 40, 0.4); color: #c62828; } 
        .p2-set .fire-btn:active { background: rgba(198, 40, 40, 0.6); color:#fff; transform: scale(0.95); }

        /* BOTTOM BAR */
        #bottomBar { 
            background: #0a0a0a; height: 12%; max-height: 80px; min-height: 50px; width: 100%; 
            display: flex; align-items: center; justify-content: space-between; padding: 0 20px; 
            border-top: 1px solid #333; color: #eee; z-index: 50; position: relative; flex-shrink: 0; box-sizing: border-box; 
        }
        .player-hud { display: flex; align-items: center; background: rgba(30, 30, 30, 0.5); padding: 5px 20px; height: 70%; border: 1px solid #444; transform: skewX(-20deg); position: relative; min-width: 22%; }
        .player-hud.p1-hud { border-left: 6px solid #2e7d32; background: linear-gradient(90deg, rgba(46,125,50,0.1), transparent); }
        .player-hud.p2-hud { border-right: 6px solid #c62828; flex-direction: row-reverse; background: linear-gradient(-90deg, rgba(198,40,40,0.1), transparent); }
        .hud-inner { transform: skewX(20deg); display: flex; align-items: center; width: 100%; justify-content: space-between; }
        .p2-hud .hud-inner { flex-direction: row-reverse; }
        .hud-info { display: flex; flex-direction: column; }
        .hud-name { font-size: 1.5vh; font-weight: bold; color: #888; letter-spacing: 1px; margin-bottom: 2px; }
        .hud-score { font-size: 4vh; font-weight: 900; line-height: 1; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.3); }
        .hud-ammo-box { display: flex; gap: 3px; background: #000; padding: 4px; border-radius: 4px; border: 1px solid #333; height: 22px; align-items: center; min-width: 100px; justify-content: flex-start; } /* Adjusted for consistent height */
        .bullet-notch { width: 6px; height: 12px; background-color: #222; transform: skewX(-20deg); border: 1px solid #111; }
        .p1-ammo .bullet-notch.filled { background: #4CAF50; box-shadow: 0 0 8px #4CAF50; border-color: #81C784; }
        .p2-ammo .bullet-notch.filled { background: #f44336; box-shadow: 0 0 8px #f44336; border-color: #e57373; }
        
        .bullet-notch.laser.filled { background: #00ffff !important; box-shadow: 0 0 8px #00ffff !important; }
        .bullet-notch.frag.filled { background: #ffaa00 !important; box-shadow: 0 0 8px #ffaa00 !important; }
        .bullet-notch.gatling.filled { background: #ff00ff !important; box-shadow: 0 0 8px #ff00ff !important; }
        .bullet-notch.triple.filled { background: #4488ff !important; box-shadow: 0 0 8px #4488ff !important; }
        .bullet-notch.deathray.filled { background: #9900ff !important; box-shadow: 0 0 8px #9900ff !important; }
        .bullet-notch.shield.filled { background: #ffffff !important; box-shadow: 0 0 8px #ffffff !important; }
        .bullet-notch.mine.filled { background: #555555 !important; box-shadow: 0 0 8px #ff0000 !important; }
        .bullet-notch.missile.filled { background: #ff4400 !important; box-shadow: 0 0 8px #ff4400 !important; }
        .tac-btn { background: #1a1a1a; border: 1px solid #444; color: #888; padding: 8px 20px; font-size: 11px; font-weight: bold; letter-spacing: 1px; cursor: pointer; clip-path: polygon(10px 0, 100% 0, 100% 100%, 0 100%, 0 10px); }
        .tac-btn:hover { background: #333; color: #fff; border-color: #666; }

        .pause-title { font-size: 40px; margin-bottom: 20px; letter-spacing: 5px; font-weight: 900; color: #fff; }
        .pause-layout { display: flex; gap: 20px; align-items: stretch; justify-content: center; height: 80%; }
        .pause-panel { background: rgba(20, 20, 20, 0.95); border: 1px solid #444; padding: 20px; border-radius: 8px; width: 300px; display: flex; flex-direction: column; }
        .pause-panel.system { border-top: 4px solid #fff; width: 200px; }
        /* OPTIMIZED SETTINGS PANEL STYLE */
        .pause-panel.settings { 
            border-top: 4px solid #00ffff; 
            width: 266px; /* MODIFIED: 2/3 of original 400px */
            position: relative; 
            overflow: hidden; 
            padding: 0; 
            background: #0f0f0f;
        }
        
        .pause-panel.controls { border-top: 4px solid #ffaa00; width: 320px; overflow-y: auto; background: rgba(18, 18, 18, 0.98); }
        .pause-panel.controls::-webkit-scrollbar { width: 4px; }
        .pause-panel.controls::-webkit-scrollbar-thumb { background: #444; }
        
        /* New Settings Internal Layout */
        .settings-header-fixed {
            padding: 15px 15px 10px 15px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            flex-shrink: 0;
        }
        
        .settings-scroll-area {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .settings-scroll-area::-webkit-scrollbar { width: 6px; }
        .settings-scroll-area::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }

        .settings-group {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            padding: 10px;
        }
        
        .group-title {
            font-size: 10px;
            font-weight: bold;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        /* Compact Controls inside Settings */
        .compact-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 11px;
        }
        .compact-row:last-child { margin-bottom: 0; }
        .compact-label { font-weight: bold; color: #ccc; }
        .compact-val { color: #00ffff; font-family: monospace; font-weight: bold; }
        
        /* Weapon Grid Row */
        .weapon-row {
            display: grid;
            grid-template-columns: 70px 1fr 35px;
            gap: 10px;
            align-items: center;
            margin-bottom: 4px;
            background: rgba(0,0,0,0.2);
            padding: 4px 8px;
            border-radius: 4px;
        }
        .weapon-name { font-size: 10px; font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        .custom-range {
            width: 100%;
            cursor: pointer;
            accent-color: #d32f2f;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }
        .custom-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 10px;
            background: #eee;
            border-radius: 50%;
            cursor: pointer;
        }

        .custom-num-input {
            width: 100%;
            background: transparent;
            border: none;
            border-bottom: 1px solid #444;
            color: #fff;
            font-family: monospace;
            font-size: 11px;
            text-align: center;
            outline: none;
            padding: 0;
        }

        /* UPGRADED APPLY BUTTON */
        .btn-apply {
            width: 100%;
            padding: 12px;
            font-weight: 900;
            text-transform: uppercase;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 5px;
            margin-top: 10px;
            touch-action: manipulation;
            font-size: 14px;
            letter-spacing: 1px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.3);
            position: relative;
            top: 0;
        }

        .btn-apply:active {
            top: 4px;
            box-shadow: 0 0 0 rgba(0,0,0,0.3);
        }

        .btn-apply.valid {
            background: linear-gradient(135deg, #43a047, #2e7d32);
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .btn-apply.valid:hover {
            background: linear-gradient(135deg, #66bb6a, #43a047);
            box-shadow: 0 6px 10px rgba(67, 160, 71, 0.4), 0 4px 0 rgba(0,0,0,0.3);
        }

        .btn-apply.invalid {
            background: #333;
            color: #777;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .control-group { background: rgba(255,255,255,0.03); padding: 12px; border-radius: 6px; margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.05); }
        .control-group.p1 { border-left: 4px solid #2e7d32; }
        .control-group.p2 { border-left: 4px solid #c62828; }
        
        .key-grid { display: grid; grid-template-columns: 1fr auto; gap: 6px 0; align-items: center; }
        .key-label { font-size: 10px; color: #888; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px; }
        
        .panel-header { font-size: 12px; font-weight: bold; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 15px; text-align: center; border-bottom: 1px solid #333; padding-bottom: 10px; flex-shrink: 0; }
        .sub-header { font-size: 10px; font-weight: bold; margin: 0 0 10px 0; padding-bottom: 5px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .key-btn { background: #111; border: 1px solid #333; color: #fff; padding: 4px 8px; cursor: pointer; font-family: monospace; min-width: 60px; border-radius: 4px; text-align: center; font-size: 11px; }
        .key-btn.fire { background: #222; border-color: #555; color: #fff; margin-top: 5px; font-weight: bold; }
        .key-btn.listening { background: #d32f2f; animation: pulse 0.5s infinite; border-color: #fff; }

        .mode-btn { width: 300px; padding: 20px; margin: 10px; font-size: 20px; font-weight: bold; cursor: pointer; border: 2px solid #444; background: #222; color: #fff; display: flex; align-items: center; justify-content: space-between; transition: 0.2s; touch-action: manipulation; }
        .mode-btn:hover { background: #333; border-color: #666; transform: scale(1.02); }
        .mode-btn.pvp { border-left: 5px solid #ffaa00; }
        .mode-btn.pve { border-left: 5px solid #00ffff; }
        .mode-desc { font-size: 12px; color: #888; font-weight: normal; display: block; margin-top: 5px;}
        .menu-btn { padding: 10px; font-size: 14px; font-weight: bold; cursor: pointer; background: #222; color: #fff; border: 1px solid #444; transition: 0.2s; text-transform: uppercase; width: 100%; touch-action: manipulation; }
        .menu-btn:hover { background: #444; border-color: #666; }
        .menu-btn.primary { background: #d32f2f; border-color: #b71c1c; }
        
        .guide-content { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; text-align: left; max-height: 500px; overflow-y: auto; padding-right: 10px; width: 800px; }
        @media screen and (max-width: 900px) { .guide-content { grid-template-columns: 1fr; width: 90vw; } }
        .guide-item { display: flex; align-items: center; background: #1a1a1a; padding: 15px; border: 1px solid #333; border-radius: 8px; }
        .guide-icon-box { width: 50px; height: 50px; background: #222; border: 2px solid #444; border-radius: 8px; display: flex; align-items: center; justify-content: center; margin-right: 15px; flex-shrink: 0; position: relative; }
        .guide-icon-box canvas { position: relative !important; width: 40px !important; height: 40px !important; top: auto !important; left: auto !important; background: transparent; }
        .guide-text h4 { margin: 0 0 5px 0; color: #fff; font-size: 16px; text-transform: uppercase; }
        .guide-text p { margin: 0 0 5px 0; font-size: 12px; color: #aaa; line-height: 1.4; }
        .game-msg { position: absolute; top: 35%; left: 0; width: 100%; text-align: center; transform: translateY(-50%); font-size: 60px; font-weight: 900; color: #fff; text-shadow: 0 5px 0 #000, 0 0 20px rgba(0,0,0,0.5); display: none; pointer-events: none; z-index: 50; text-transform: uppercase; letter-spacing: 5px; }

        .device-option { width: 200px; height: 200px; border: 2px solid #444; margin: 20px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; background: #151515; transition: 0.2s; border-radius: 10px; touch-action: manipulation; }
        .device-option:hover { background: #222; border-color: #fff; transform: scale(1.05); }
        .device-icon { font-size: 60px; margin-bottom: 20px; }
        .device-label { font-size: 20px; font-weight: bold; text-transform: uppercase; }

        .cycle-btn { background: #333; border: 1px solid #555; color: #fff; padding: 4px 10px; cursor: pointer; font-size: 11px; border-radius: 4px; min-width: 80px; text-align: center; font-weight: bold; }
        .cycle-btn:hover { background: #444; border-color: #888; }
        
        input[type="checkbox"] { width: 16px; height: 16px; accent-color: #d32f2f; cursor: pointer; }

        /* AI Commentary Box */
        #aiCommentary {
            position: absolute;
            bottom: 12%; 
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            text-align: center;
            color: #ffeb3b;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 90;
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.7), transparent);
            padding: 10px 0;
        }
        #aiCommentary.show {
            opacity: 1;
        }

        /* Sparkle Button for Gemini Features */
        .sparkle-btn {
            background: linear-gradient(135deg, #673ab7, #512da8);
            color: #fff;
            border: 1px solid #9575cd;
            box-shadow: 0 0 10px rgba(103, 58, 183, 0.5);
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        .sparkle-btn:hover {
            background: linear-gradient(135deg, #7e57c2, #673ab7);
            box-shadow: 0 0 15px rgba(103, 58, 183, 0.8);
        }

        /* Advice Modal */
        #adviceContent {
            background: #1a1a1a;
            padding: 20px;
            border: 2px solid #673ab7;
            border-radius: 8px;
            max-width: 80%;
            text-align: center;
            font-size: 16px;
            color: #eee;
            margin-bottom: 20px;
            line-height: 1.5;
        }
    </style>
</head>
<body>

<div id="rotateOverlay">
    <div class="rotate-icon">‚Üª</div>
    <h2>VUI L√íNG XOAY NGANG ƒêI·ªÜN THO·∫†I</h2>
    <p>PLEASE ROTATE YOUR DEVICE</p>
</div>

<div id="gameWrapper">
    <div id="canvasContainer">
        <canvas id="bgCanvas" width="1365" height="780" class="game-layer"></canvas>
        <canvas id="gameCanvas" width="1365" height="780" class="game-layer"></canvas>
        <div id="aiCommentary"></div> <!-- AI Commentary Box -->
    </div>
    
    <div id="gameMessage" class="game-msg">DRAW!</div>
    
    <div id="deviceSelectModal">
        <h1 style="margin-bottom: 40px;">SELECT CONTROL METHOD</h1>
        <div style="display: flex;">
            <div class="device-option" onclick="window.selectDevice('pc')">
                <div class="device-icon">‚å®Ô∏è</div>
                <div class="device-label">PC / Keyboard</div>
            </div>
            <div class="device-option" onclick="window.selectDevice('mobile')">
                <div class="device-icon">üì±</div>
                <div class="device-label">Mobile / 2 Players</div>
            </div>
        </div>
    </div>

    <div id="menuOverlay">
        <div class="main-title-box"><span class="title-prefix">WindHouse</span><h1 class="game-title">Tank Battle</h1></div>
        <div class="controls-container">
            <div class="player-card-ui p1">
                <div class="p-label">PLAYER 1</div>
                <div class="ctrl-row">Move <span class="key-cap">‚Üë</span><span class="key-cap">‚Üì</span><span class="key-cap">‚Üê</span><span class="key-cap">‚Üí</span></div>
                <div class="ctrl-row">Fire <span class="key-cap" style="min-width:60px;">K</span></div>
            </div>
            <div class="player-card-ui p2">
                <div class="p-label">PLAYER 2</div>
                <div class="ctrl-row">Move <span class="key-cap">E</span><span class="key-cap">D</span><span class="key-cap">S</span><span class="key-cap">F</span></div>
                <div class="ctrl-row">Fire <span class="key-cap" style="min-width:60px;">Q</span></div>
            </div>
        </div>
        <div class="btn-group">
            <button class="btn-main btn-start" onclick="window.showModeSelect()">START MISSION</button>
            <button class="btn-main btn-guide" onclick="window.openGuide()">ARMORY</button>
        </div>
        <div style="margin-top: 40px; font-size: 10px; color: #555; font-weight: bold; letter-spacing: 1px; text-transform: uppercase;">
            [F] Fullscreen | v64.0 (Mod)
        </div>
    </div>

    <div id="mobileControls">
        <div class="control-set p1-set">
            <div class="fire-btn" id="btnFireP1">FIRE</div>
            <div class="touch-zone" id="joyP1">
                <div class="stick-knob" id="knobP1"></div>
            </div>
        </div>

        <div class="control-set p2-set">
            <div class="fire-btn" id="btnFireP2">FIRE</div>
            <div class="touch-zone" id="joyP2">
                <div class="stick-knob" id="knobP2"></div>
            </div>
        </div>
    </div>

    <div id="modeSelectModal">
        <h2 style="color:#fff; margin-bottom: 20px;">SELECT GAME MODE</h2>
        <button class="mode-btn pvp" onclick="window.selectMode('pvp')"><span>2 PLAYER (PvP)</span><div class="mode-desc">Duel with a friend</div></button>
        <button class="mode-btn pve" onclick="window.selectMode('pve')"><span>PLAYER vs MAGIC AI</span><div class="mode-desc">Advanced Aim & Tactics</div></button>
        <button class="menu-btn" style="margin-top:20px; width: 150px;" onclick="window.closeModeSelect()">BACK</button>
    </div>

    <div id="guideModal">
        <h2>WEAPON GUIDE</h2>
        <div class="guide-content"></div>
        <button class="menu-btn" style="margin-top:20px; width: 150px; background:#333;" onclick="window.closeGuide()">BACK</button>
    </div>

    <div id="aiAdviceModal">
        <h2 style="color: #b39ddb; margin-bottom: 20px;">‚ú® GENERAL GEMINI SAYS ‚ú®</h2>
        <div id="adviceContent">Analysing battlefield strategy...</div>
        <button class="menu-btn" style="margin-top:10px; width: 150px;" onclick="window.closeAdvice()">THANKS!</button>
    </div>

    <div id="settingsModal">
        <div class="pause-title">PAUSED</div>
        <div class="pause-layout">
            <div class="pause-panel system">
                <div class="panel-header">SYSTEM</div>
                <div style="display:flex; flex-direction:column; gap:8px;">
                    <button class="menu-btn primary" onclick="window.closeSettings()">RESUME</button>
                    <!-- REMOVED GEMINI BUTTON -->
                    <button class="menu-btn" onclick="window.restartMatch()">RESTART</button>
                    <button class="menu-btn" onclick="window.quitToMenu()">EXIT MENU</button>
                </div>
            </div>

            <!-- RESTRUCTURED SETTINGS PANEL -->
            <div class="pause-panel settings" id="mainSettingsPanel">
                <!-- Content injected by JS -->
            </div>
            
            <div class="pause-panel controls" id="controlsPanelContent">
                <!-- CONTROLS INJECTED HERE -->
            </div>
        </div>
    </div>

    <div id="bottomBar">
        <div class="player-hud p2-hud">
            <div class="hud-inner">
                <div class="hud-info" style="align-items: flex-end;">
                    <div class="hud-name" id="p2NameUI">RED PLAYER</div>
                    <div class="hud-score" id="s2">0</div>
                </div>
                <div class="hud-ammo-box p2-ammo" id="ammo-p2"></div>
            </div>
        </div>

        <div style="display: flex; flex-direction: column; align-items: center; z-index: 2;">
            <div style="font-size: 9px; color:#444; letter-spacing: 2px; font-weight: bold; margin-bottom: 4px;">TACTICAL SYSTEM</div>
            <button class="tac-btn" onclick="window.openSettings()">MENU / CONFIG</button>
        </div>

        <div class="player-hud p1-hud">
            <div class="hud-inner">
                <div class="hud-info">
                    <div class="hud-name">GREEN PLAYER</div>
                    <div class="hud-score" id="s1">0</div>
                </div>
                <div class="hud-ammo-box p1-ammo" id="ammo-p1"></div>
            </div>
        </div>
    </div>
</div>

<script>
    // --- GLOBAL SETUP ---
    const apiKey = ""; // API Key provided by runtime
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const bgCanvas = document.getElementById('bgCanvas');
    const bgCtx = bgCanvas.getContext('2d');

    const menu = document.getElementById('menuOverlay');
    const settingsModal = document.getElementById('settingsModal');
    const guideModal = document.getElementById('guideModal');
    const modeModal = document.getElementById('modeSelectModal');
    const deviceModal = document.getElementById('deviceSelectModal');
    const adviceModal = document.getElementById('aiAdviceModal');
    const msgBox = document.getElementById('gameMessage');
    const aiCommentaryBox = document.getElementById('aiCommentary');
    
    let gameRunning = false, gamePaused = false, roundEnding = false, roundEndTimer = null;
    let gameMode = 'pvp';
    let isMobile = false; 
    let remapping = null;
    
    let mobileInput = {
        p1: { x: 0, y: 0, fire: false },
        p2: { x: 0, y: 0, fire: false }
    };

    let mobileSettings = {
        p1: { sensitivity: 1.0, size: 100, swap: false },
        p2: { sensitivity: 1.0, size: 100, swap: false }
    };

    let scores = { p1: 0, p2: 0 };
    let keys = {};
    let animationId;
    let timerSpawnItems = 0; 
    let gameSettings = { spawnTime: 15, maxItems: 5 }; 
    let shakeAmount = 0;

    // --- AI CONFIGURATION ---
    const AI_DIFFICULTY = {
        EASY: { reaction: 45, aimErr: 0.35, moveSpeed: 1.5, bounces: 0 },
        NORMAL: { reaction: 20, aimErr: 0.08, moveSpeed: 2.2, bounces: 1 },
        HARD: { reaction: 8, aimErr: 0.02, moveSpeed: 2.5, bounces: 2 },
        INSANE: { reaction: 0, aimErr: 0.0, moveSpeed: 3.0, bounces: 3 }
    };

    const AI_PERSONALITY = {
        BALANCED: { type: 'balanced', label: 'BALANCED' },
        RUSHER: { type: 'rusher', label: 'RUSHER (AGGRO)' },
        SNIPER: { type: 'sniper', label: 'SNIPER (CAMP)' },
        CAMPER: { type: 'camper', label: 'CAMPER (HIDE)' }
    };

    let aiConfig = {
        difficulty: 'NORMAL',
        personality: 'BALANCED'
    };

    let bullets=[], walls=[], particles=[], powerups=[]; 
    let activeLasers = [];
    let mazeGrid = []; 
    const cellSize=65, wallThickness=5;
    let wallPath=new Path2D();
    let tracks = [];

    const controls = {
        p1: { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight', shoot: 'KeyK' },
        p2: { up: 'KeyE', down: 'KeyD', left: 'KeyS', right: 'KeyF', shoot: 'KeyQ' }
    };

    const RELOAD_TIME = 75, MAX_AMMO = 5;
    
    const WEAPONS = {
        NORMAL: { ammo: 5, color: '#222', cooldown: 15 },
        LASER: { ammo: 1, color: '#00ffff', cooldown: 90, weight: 11, desc: "B·∫Øn xuy√™n b·∫£n ƒë·ªì." },
        FRAG: { ammo: 1, color: '#ffaa00', cooldown: 60, weight: 11, desc: "N·ªï ra 13 m·∫£nh (Ch·ªù 3s)." },
        GATLING: { ammo: 10, color: '#ff00ff', cooldown: 4, weight: 11, desc: "S√∫ng m√°y nhanh." },
        TRIPLE: { ammo: 1, color: '#4488ff', cooldown: 60, weight: 11, desc: "Shotgun 3 tia." },
        DEATHRAY: { ammo: 1, color: '#9900ff', cooldown: 180, weight: 11, desc: "Qu√©t s·∫°ch 180 ƒë·ªô." },
        SHIELD: { ammo: 1, color: '#ffffff', cooldown: 0, weight: 11, desc: "Ph·∫£n ƒë·∫°n & Ch·∫∑n Laser (5s)." },
        MINE: { ammo: 1, color: '#000000', cooldown: 60, weight: 11, desc: "ƒê·∫∑t m√¨n t√†ng h√¨nh (3s)." },
        MISSILE: { ammo: 1, color: '#ff4400', cooldown: 120, weight: 11, desc: "T√¨m ƒë∆∞·ªùng, d·ªôi t∆∞·ªùng." },
        FLAME: { ammo: 40, color: '#ff5722', cooldown: 3, weight: 12, desc: "Phun l·ª≠a t·∫ßm g·∫ßn." }
    };

    const POWERUP_TYPES = ['LASER', 'FRAG', 'GATLING', 'TRIPLE', 'DEATHRAY', 'SHIELD', 'MINE', 'MISSILE', 'FLAME'];
    let pendingWeights = {}; 

    // --- GEMINI API INTEGRATION ---
    let isGeminiBusy = false;

    async function callGemini(promptText) {
        if (isGeminiBusy) return null;
        isGeminiBusy = true;
        
        try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: promptText }] }]
                })
            });

            if (!response.ok) throw new Error('API Error');
            const data = await response.json();
            isGeminiBusy = false;
            return data.candidates?.[0]?.content?.parts?.[0]?.text;
        } catch (e) {
            console.error("Gemini Error:", e);
            isGeminiBusy = false;
            return null;
        }
    }

    // Feature 1: Commentary
    async function triggerAICommentary(type, details) {
        // Only trigger occasionally to avoid spam
        if (Math.random() > 0.7 && type !== 'start') return;

        let prompt = "";
        if (type === 'start') {
            prompt = "You are a hyped esports announcer for a tank battle game. Write a very short (max 10 words) 'Ready Set Go' style intro to start the match.";
        } else if (type === 'kill') {
            prompt = `You are a sarcastic esports commentator. ${details.killer} just killed ${details.victim} using ${details.weapon}. Write a very short (max 15 words) funny or snarky comment about this kill.`;
        } else if (type === 'win') {
             prompt = `Write a short (max 10 words) epic victory shout for ${details.winner} who just won the tank battle.`;
        }

        const text = await callGemini(prompt);
        if (text) showCommentary(text);
    }

    function showCommentary(text) {
        aiCommentaryBox.innerText = text.replace(/['"]+/g, ''); // Remove quotes
        aiCommentaryBox.classList.add('show');
        setTimeout(() => {
            aiCommentaryBox.classList.remove('show');
        }, 4000);
    }

    // Feature 2: Tactical Advice
    async function askGeminiAdvice() {
        const adviceContent = document.getElementById('adviceContent');
        adviceContent.innerText = "General Gemini is analyzing the battlefield...";
        adviceModal.style.display = 'flex';
        
        // Gather game state
        let losingPlayer = scores.p1 < scores.p2 ? "Green Player (P1)" : "Red Player (P2)";
        if (scores.p1 === scores.p2) losingPlayer = "both players";
        
        let prompt = `You are a military general advising in a 2D top-down tank shooter maze game. 
        Current State: Green Player has ${p1.weaponType} with ${p1.ammo} ammo. Red Player has ${p2.weaponType} with ${p2.ammo} ammo.
        Score: Green ${scores.p1} - ${scores.p2} Red.
        Give one single, short (max 20 words) tactical tip specifically for ${losingPlayer} to turn the tide. Focus on weapon usage or movement.`;

        const text = await callGemini(prompt);
        if (text) {
            adviceContent.innerText = `"${text.trim()}"`;
        } else {
            adviceContent.innerText = "Radio silence... (Connection error)";
        }
    }

    function closeAdvice() {
        adviceModal.style.display = 'none';
    }


    // --- MATH HELPERS ---
    function dist(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }
    function distToSegment(p, v, w) {
        function sqr(x) { return x * x }
        function dist2(v, w) { return sqr(v.x - w.x) + sqr(v.y - w.y) }
        var l2 = dist2(v, w);
        if (l2 == 0) return dist(p.x, p.y, v.x, v.y);
        var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        return Math.sqrt(dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) }));
    }
    function circleRectCollide(cx, cy, cr, rx, ry, rw, rh) {
        let testX = cx < rx ? rx : (cx > rx + rw ? rx + rw : cx);
        let testY = cy < ry ? ry : (cy > ry + rh ? ry + rh : cy);
        let distX = cx - testX; let distY = cy - testY;
        return (distX*distX) + (distY*distY) <= (cr*cr);
    }
    function checkWallCollision(x, y, radius) {
        for (let w of walls) { if (circleRectCollide(x,y,radius,w.x,w.y,w.w,w.h)) return true; } 
        return false; 
    }
    function checkWall(x, y, r) { return checkWallCollision(x,y,r); }
    function lineIntersectsRect(x1, y1, x2, y2, rx, ry, rw, rh) {
        let left = lineLine(x1,y1,x2,y2, rx,ry,rx, ry+rh);
        let right = lineLine(x1,y1,x2,y2, rx+rw,ry, rx+rw,ry+rh);
        let top = lineLine(x1,y1,x2,y2, rx,ry, rx+rw,ry);
        let bottom = lineLine(x1,y1,x2,y2, rx,ry+rh, rx+rw,ry+rh);
        return left || right || top || bottom;
    }
    function lineLine(x1, y1, x2, y2, x3, y3, x4, y4) {
        let uA = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));
        let uB = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));
        return (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1);
    }
    function hasLineOfSight(x1, y1, x2, y2) {
        for (let w of walls) {
            if (lineIntersectsRect(x1, y1, x2, y2, w.x - 10, w.y - 10, w.w + 20, w.h + 20)) return false;
        }
        return true;
    }

    // --- VFX CLASSES ---
    class TrackMark {
        constructor(x, y, angle) {
            this.x = x; this.y = y; this.angle = angle;
            this.life = 300; this.maxLife = 300;
        }
        update() { this.life--; }
        draw(ctx) {
            if (this.life <= 0) return;
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
            ctx.globalAlpha = (this.life / this.maxLife) * 0.3; ctx.fillStyle = "#000"; 
            ctx.fillRect(-12, -10, 24, 6); ctx.fillRect(-12, 4, 24, 6);
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, type, color) {
            this.x=x; this.y=y; this.type=type; this.color=color;
            let a = Math.random()*Math.PI*2;
            let s = (type==='spark') ? Math.random()*3+2 : Math.random()*4;
            if (type === 'debris') s = Math.random() * 2;
            this.vx=Math.cos(a)*s; this.vy=Math.sin(a)*s;
            this.size = Math.random()*3+1; this.life=1.0; 
            if(type==='beam') { this.decay=0.05; }
            else if(type==='fragment') { this.vx*=1.5; this.vy*=1.5; this.size=3; this.decay=0.015; }
            else if(type==='fire') { this.decay=0.03; }
            else if(type==='smoke') { 
                this.vx*=0.3; this.vy*=0.3; this.size=Math.random()*4+4; this.decay=0.04; 
                if (color === '#444' || color === '#888' || !color) this.color="rgba(100,100,100,0.4)"; 
            }
            else if(type==='flash') { this.vx=0; this.vy=0; this.size=30; this.decay=0.2; this.color="#fff"; }
            else if(type==='impact_ring') { this.vx=0; this.vy=0; this.size=2; this.decay=0.1; }
            else if(type==='debris') { this.decay=0.02; this.size=Math.random()*2+1; }
            else { this.decay=0.03; }
        }
        update() { 
            this.x+=this.vx; this.y+=this.vy; this.life-=this.decay; 
            if(this.type==='impact_ring') { this.size += 3; }
            else if(this.type==='fragment' || this.type==='debris') { 
                this.vx*=0.9; this.vy*=0.9; 
                if(this.x<0||this.x>canvas.width)this.vx*=-1; if(this.y<0||this.y>canvas.height)this.vy*=-1;
            } 
            else { this.vx*=0.95; this.vy*=0.95; }
        }
        draw() { 
            ctx.save(); ctx.globalAlpha=Math.max(0,this.life); 
            if (this.type === 'impact_ring') {
                ctx.strokeStyle = this.color; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.stroke();
            } else if (this.type === 'smoke') {
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.fillStyle=this.color; 
                if(this.type === 'debris') ctx.fillRect(this.x, this.y, this.size, this.size);
                else { ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill(); }
            }
            ctx.restore();
        }
    }

    class PowerUp {
        constructor(x, y) {
            this.x=x; this.y=y; this.active=true;
            let totalWeight = 0;
            POWERUP_TYPES.forEach(t => totalWeight += WEAPONS[t].weight);
            let rnd = Math.random() * totalWeight;
            for(let t of POWERUP_TYPES) {
                rnd -= WEAPONS[t].weight;
                if(rnd <= 0) { this.type = t; break; }
            }
            if (!this.type) this.type = POWERUP_TYPES[0]; 
            this.angle=0;
        }
        draw() {
            if(!this.active) return;
            this.angle += 0.03;
            let rockAngle = Math.sin(this.angle) * 0.25; 
            let color = WEAPONS[this.type].color;
            ctx.save(); ctx.translate(this.x, this.y); 
            ctx.shadowColor = color; ctx.shadowBlur = 15; ctx.fillStyle = "rgba(0,0,0,0.3)";
            ctx.beginPath(); ctx.arc(0,0, 18, 0, Math.PI*2); ctx.fill();
            ctx.rotate(rockAngle);
            ctx.shadowBlur = 5; ctx.fillStyle = "#222";
            ctx.beginPath(); ctx.moveTo(-14, -14); ctx.lineTo(14, -14); ctx.lineTo(14, 14); ctx.lineTo(-14, 14); ctx.closePath(); ctx.fill();
            ctx.strokeStyle = color; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(-14, -10); ctx.lineTo(-10, -14); ctx.lineTo(10, -14); ctx.lineTo(14, -10);
            ctx.lineTo(14, 10); ctx.lineTo(10, 14); ctx.lineTo(-10, 14); ctx.lineTo(-14, 10); ctx.closePath(); ctx.stroke();
            ctx.shadowBlur = 0; ctx.scale(1.1, 1.1);
            drawItem(ctx, this.type);
            ctx.restore();
        }
    }
    
    // --- DRAW ITEM FUNCTION RESTORED ---
    function drawItem(ctxToUse, type) {
        ctxToUse.save(); ctxToUse.shadowColor = WEAPONS[type] ? WEAPONS[type].color : "#fff"; ctxToUse.shadowBlur = 8;
        switch(type) {
            case 'GATLING': ctxToUse.strokeStyle = WEAPONS.GATLING.color; ctxToUse.lineWidth = 1.5; ctxToUse.beginPath(); ctxToUse.arc(0,0, 5, 0, Math.PI*2); ctxToUse.stroke(); for(let i=0; i<6; i++) { ctxToUse.save(); ctxToUse.rotate(i * Math.PI/3); ctxToUse.beginPath(); ctxToUse.arc(8, 0, 2.5, 0, Math.PI*2); ctxToUse.stroke(); ctxToUse.restore(); } break;
            case 'FRAG': ctxToUse.strokeStyle = WEAPONS.FRAG.color; ctxToUse.lineWidth = 2; ctxToUse.beginPath(); ctxToUse.arc(0, 2, 7, 0, Math.PI*2); ctxToUse.stroke(); ctxToUse.lineWidth = 1; ctxToUse.beginPath(); ctxToUse.arc(-6, -6, 3, 0, Math.PI*2); ctxToUse.stroke(); ctxToUse.beginPath(); ctxToUse.arc(6, -6, 3, 0, Math.PI*2); ctxToUse.stroke(); ctxToUse.beginPath(); ctxToUse.arc(0, -9, 2, 0, Math.PI*2); ctxToUse.stroke(); break;
            case 'LASER': ctxToUse.fillStyle = WEAPONS.LASER.color; ctxToUse.fillRect(-10, -5, 20, 2); ctxToUse.fillRect(-10, 3, 20, 2); ctxToUse.shadowBlur = 15; ctxToUse.shadowColor = "#fff"; ctxToUse.fillRect(-10, -1, 20, 2); break;
            case 'TRIPLE': ctxToUse.strokeStyle = WEAPONS.TRIPLE.color; ctxToUse.lineWidth = 2; ctxToUse.lineCap = "round"; ctxToUse.beginPath(); ctxToUse.arc(-8, 0, 2, 0, Math.PI*2); ctxToUse.fill(); ctxToUse.beginPath(); ctxToUse.moveTo(-6, 0); ctxToUse.lineTo(10, 0); ctxToUse.stroke(); ctxToUse.beginPath(); ctxToUse.moveTo(-6, 0); ctxToUse.lineTo(8, -6); ctxToUse.stroke(); ctxToUse.beginPath(); ctxToUse.moveTo(-6, 0); ctxToUse.lineTo(8, 6); ctxToUse.stroke(); ctxToUse.beginPath(); ctxToUse.moveTo(12,0); ctxToUse.lineTo(8,-2); ctxToUse.lineTo(8,2); ctxToUse.fill(); break;
            case 'DEATHRAY': ctxToUse.strokeStyle = WEAPONS.DEATHRAY.color; ctxToUse.lineWidth = 1.5; ctxToUse.beginPath(); ctxToUse.arc(-5, 0, 10, -Math.PI/2, Math.PI/2); ctxToUse.stroke(); ctxToUse.fillStyle = WEAPONS.DEATHRAY.color; ctxToUse.beginPath(); ctxToUse.arc(-5, 0, 3, 0, Math.PI*2); ctxToUse.fill(); ctxToUse.lineWidth = 1; ctxToUse.beginPath(); ctxToUse.arc(-5, 0, 14, -0.8, 0.8); ctxToUse.stroke(); ctxToUse.beginPath(); ctxToUse.arc(-5, 0, 18, -0.6, 0.6); ctxToUse.stroke(); break;
            case 'MISSILE': ctxToUse.translate(0, 2); ctxToUse.rotate(-Math.PI/4); ctxToUse.strokeStyle = WEAPONS.MISSILE.color; ctxToUse.lineWidth = 1.5; ctxToUse.beginPath(); ctxToUse.moveTo(-4, -6); ctxToUse.lineTo(4, -6); ctxToUse.lineTo(0, -12); ctxToUse.closePath(); ctxToUse.stroke(); ctxToUse.strokeRect(-4, -6, 8, 12); ctxToUse.beginPath(); ctxToUse.moveTo(-4, 4); ctxToUse.lineTo(-8, 8); ctxToUse.lineTo(-4, 6); ctxToUse.stroke(); ctxToUse.beginPath(); ctxToUse.moveTo(4, 4); ctxToUse.lineTo(8, 8); ctxToUse.lineTo(4, 6); ctxToUse.stroke(); ctxToUse.shadowColor = "red"; ctxToUse.strokeStyle = "red"; ctxToUse.beginPath(); ctxToUse.arc(0, -9, 5, 0, Math.PI*2); ctxToUse.stroke(); ctxToUse.beginPath(); ctxToUse.moveTo(0, -16); ctxToUse.lineTo(0, -2); ctxToUse.stroke(); ctxToUse.beginPath(); ctxToUse.moveTo(-7, -9); ctxToUse.lineTo(7, -9); ctxToUse.stroke(); break;
            case 'MINE': ctxToUse.strokeStyle = WEAPONS.MINE.color; ctxToUse.lineWidth = 2; ctxToUse.beginPath(); ctxToUse.arc(0,0, 7, 0, Math.PI*2); ctxToUse.stroke(); for(let i=0; i<4; i++) { ctxToUse.save(); ctxToUse.rotate(i * Math.PI/2 + Math.PI/4); ctxToUse.beginPath(); ctxToUse.moveTo(7, 0); ctxToUse.lineTo(12, 0); ctxToUse.stroke(); ctxToUse.restore(); } ctxToUse.shadowColor = "red"; ctxToUse.shadowBlur = 10; ctxToUse.fillStyle = "red"; ctxToUse.beginPath(); ctxToUse.arc(0,0, 3, 0, Math.PI*2); ctxToUse.fill(); break;
            case 'SHIELD': ctxToUse.strokeStyle = WEAPONS.SHIELD.color; ctxToUse.lineWidth = 2; ctxToUse.strokeRect(-6, -2, 12, 6); ctxToUse.strokeRect(-2, -6, 4, 4); ctxToUse.shadowBlur = 15; ctxToUse.lineWidth = 3; ctxToUse.beginPath(); ctxToUse.arc(0,0, 13, 0, Math.PI*2); ctxToUse.stroke(); break;
            case 'FLAME': ctxToUse.fillStyle = "#ff5722"; ctxToUse.beginPath(); ctxToUse.moveTo(-5, 8); ctxToUse.quadraticCurveTo(0, -15, 5, 8); ctxToUse.fill(); ctxToUse.fillStyle = "#ff9800"; ctxToUse.beginPath(); ctxToUse.arc(0, 5, 3, 0, Math.PI*2); ctxToUse.fill(); break;
            default: ctxToUse.fillStyle = WEAPONS[type] ? WEAPONS[type].color : "#fff"; ctxToUse.fillRect(-6,-6,12,12); break;
        }
        ctxToUse.shadowBlur = 0; ctxToUse.restore();
    }

    class LaserBeam {
        constructor(x, y, angle, owner, life = 90) {
            this.start = {x: x, y: y};
            let len = 3000; if (owner.weaponType === 'DEATHRAY') len = 280; 
            this.end = { x: x + Math.cos(angle) * len, y: y + Math.sin(angle) * len };
            this.owner = owner; this.life = life; this.maxLife = life; this.active = true;
            this.color = (owner.weaponType === 'DEATHRAY') ? WEAPONS.DEATHRAY.color : WEAPONS.LASER.color;
            this.angle = angle;
            this.curveTarget = null;
            if (owner.weaponType === 'LASER') { 
                let potentialTargets = [p1, p2];
                for(let t of potentialTargets) {
                    if (t === owner || t.dead) continue;
                    let dx = t.x - x; let dy = t.y - y;
                    let angleToTarget = Math.atan2(dy, dx);
                    let diff = angleToTarget - angle;
                    while(diff < -Math.PI) diff += Math.PI*2; while(diff > Math.PI) diff -= Math.PI*2;
                    if (Math.abs(diff) < 0.26 && Math.hypot(dx, dy) < 3000) { this.curveTarget = t; this.end = {x: t.x, y: t.y}; }
                }
            }
        }
        update() {
            this.life--; if(this.life <= 0) this.active = false;
            const checkHit = (tank) => {
                if (!tank.dead && this.owner !== tank) {
                    if (this.curveTarget === tank) { 
                        if (tank.activeShield) { createSparks(tank.x, tank.y, "#fff", 5); return; }
                        tank.takeDamage(this.owner, null); return; 
                    }
                    let d = distToSegment({x: tank.x, y: tank.y}, this.start, this.end);
                    if (d < 25) { 
                        if (tank.activeShield) { createSparks(tank.x, tank.y, this.color, 3); createSparks(tank.x, tank.y, "#ffffff", 2); return; }
                        tank.takeDamage(this.owner, null); 
                    }
                }
            };
            checkHit(p1); checkHit(p2);
        }
        draw() {
            let ratio = this.life / this.maxLife; let width = 10 * ratio + Math.random() * 5; let opacity = Math.min(1, ratio * 1.5); 
            ctx.save(); ctx.globalAlpha = opacity; ctx.lineCap = "round";
            ctx.shadowBlur = 20 * ratio + Math.random() * 10; ctx.shadowColor = this.color;
            ctx.strokeStyle = this.color; ctx.lineWidth = width + 10; 
            ctx.beginPath(); ctx.moveTo(this.start.x, this.start.y); 
            if (this.curveTarget) {
                let cpLen = Math.hypot(this.curveTarget.x - this.start.x, this.curveTarget.y - this.start.y) / 2;
                let cpX = this.start.x + Math.cos(this.angle) * cpLen; let cpY = this.start.y + Math.sin(this.angle) * cpLen;
                ctx.quadraticCurveTo(cpX, cpY, this.curveTarget.x, this.curveTarget.y);
            } else { ctx.lineTo(this.end.x, this.end.y); }
            ctx.stroke();
            ctx.shadowBlur = 0; ctx.strokeStyle = "white"; ctx.lineWidth = width; 
            ctx.beginPath(); ctx.moveTo(this.start.x, this.start.y); 
            if (this.curveTarget) {
                let cpLen = Math.hypot(this.curveTarget.x - this.start.x, this.curveTarget.y - this.start.y) / 2;
                let cpX = this.start.x + Math.cos(this.angle) * cpLen; let cpY = this.start.y + Math.sin(this.angle) * cpLen;
                ctx.quadraticCurveTo(cpX, cpY, this.curveTarget.x, this.curveTarget.y);
            } else { ctx.lineTo(this.end.x, this.end.y); }
            ctx.stroke(); ctx.restore();
        }
    }

    class Bullet {
        constructor(x, y, angle, color, type, owner) {
            this.x=x; this.y=y; this.type=type; this.owner=owner; this.color=color;
            let speed = 3.0; this.radius=2.5; this.life=480; this.friction = 1.0; 
            if(type==='frag') { speed = 4.0 * (2/3); this.radius=5; this.life=180; }
            if(type==='mini') { speed=5.0; this.radius=1.5; this.life=300; } 
            if(type==='fragment') { 
                let rndSpeed = 3 + Math.random() * 3;
                this.vx = Math.cos(angle) * rndSpeed; this.vy = Math.sin(angle) * rndSpeed;
                this.radius = 3; this.life = 240; this.friction = 0.94; 
            } else if (type === 'mine') {
                this.radius = 4; this.speed = 0; this.life = 3600; this.armingTime = 180; this.vx = 0; this.vy = 0; this.visible = true; 
            } else if (type === 'flame') {
                let rndSpeed = 6 + Math.random() * 3;
                this.vx = Math.cos(angle) * rndSpeed; this.vy = Math.sin(angle) * rndSpeed;
                this.radius = 3; this.life = 200; this.friction = 0.98; // MODIFIED: Range decreased to 200 (was 250)
                this.maxLife = 200;
            } else if (type === 'missile') {
                this.radius = 5; this.speed = 2.0; this.stage2Speed = 3.2; this.life = 600; this.maxLife = 600; 
                this.angle = angle; this.vx = Math.cos(angle) * this.speed; this.vy = Math.sin(angle) * this.speed;
                this.smokeTimer = 0; this.lockedTargetColor = null; 
                this.path = []; // A* path storage
                this.pathIndex = 0;
                this.pathUpdateTimer = 0;
            } else { this.vx=Math.cos(angle)*speed; this.vy=Math.sin(angle)*speed; }
            this.dead=false;
        }
        update(walls) {
            this.life--; 
            if(this.life<=0) { 
                this.dead=true; 
                if(this.type==='frag') explodeFrag(this.x,this.y,this.color); 
                if(this.type==='mine' || this.type==='missile') createExplosion(this.x, this.y, this.color); 
            }
            if (this.type === 'flame') {
                this.vx *= this.friction; this.vy *= this.friction;
                this.radius += 0.15; // Fire expands
                this.x += this.vx; this.y += this.vy;
                
                // Ghost Flame: No collision death check against walls
                
                // Destroy other bullets logic
                for(let other of bullets) {
                     if (other !== this && !other.dead && other.type !== 'flame' && other.type !== 'mine' && other.type !== 'laser') {
                         if (dist(this.x, this.y, other.x, other.y) < this.radius + other.radius) {
                             other.dead = true;
                             createSmoke(other.x, other.y);
                         }
                     }
                }
                return;
            }
            if (this.type === 'missile') {
                this.smokeTimer++;
                let smokeColor = this.lockedTargetColor ? this.lockedTargetColor : '#444';
                if (this.smokeTimer > 2) { particles.push(new Particle(this.x - Math.cos(this.angle)*5, this.y - Math.sin(this.angle)*5, 'smoke', smokeColor)); this.smokeTimer = 0; }
                if (this.maxLife - this.life > 180) { // Delay tracking start by 3 sec (180 frames)
                    this.speed = this.stage2Speed;
                    
                    let target = null;
                    let minDist = 99999;
                    const candidates = [p1, p2];
                    for (let c of candidates) {
                        if (c.dead) continue;
                        let d = dist(this.x, this.y, c.x, c.y);
                        if (d < minDist) { minDist = d; target = c; }
                    }

                    if (target) {
                        this.lockedTargetColor = target.color;
                        if (this.pathUpdateTimer++ % 10 === 0 || this.path.length === 0) {
                            this.path = getAStarPath(this.x, this.y, target.x, target.y);
                            this.pathIndex = 0;
                        }
                        let targetAngle = this.angle;
                        if (this.path.length > 0) {
                            let node = this.path[this.pathIndex];
                            if (node) {
                                let nextX = node.x * cellSize + cellSize/2;
                                let nextY = node.y * cellSize + cellSize/2;
                                targetAngle = Math.atan2(nextY - this.y, nextX - this.x);
                                if (dist(this.x, this.y, nextX, nextY) < 30) {
                                    this.pathIndex++;
                                    if(this.pathIndex >= this.path.length) { this.path = []; }
                                }
                            }
                        } else { targetAngle = Math.atan2(target.y - this.y, target.x - this.x); }
                        let diff = targetAngle - this.angle;
                        while(diff < -Math.PI) diff += Math.PI*2; while(diff > Math.PI) diff -= Math.PI*2;
                        let turnSpeed = 0.15; 
                        this.angle += Math.sign(diff) * Math.min(Math.abs(diff), turnSpeed);
                    }
                    this.vx = Math.cos(this.angle) * this.speed; this.vy = Math.sin(this.angle) * this.speed;
                }
            }
            if (this.type === 'mine') {
                if (this.armingTime > 0) { this.armingTime--; return; }
                this.visible = false; 
                let hitP1 = !p1.dead && Math.hypot(this.x-p1.x, this.y-p1.y) < 15;
                let hitP2 = !p2.dead && Math.hypot(this.x-p2.x, this.y-p2.y) < 15;
                if (hitP1 || hitP2) { this.dead = true; createExplosion(this.x, this.y, "red", true); if(hitP1) p1.takeDamage(null, this); if(hitP2) p2.takeDamage(null, this); }
                return; 
            }
            if(this.type === 'fragment') { this.vx *= this.friction; this.vy *= this.friction; if(Math.abs(this.vx) < 0.05 && Math.abs(this.vy) < 0.05) { this.vx = 0; this.vy = 0; } }
            let steps = (this.type==='frag') ? 5 : 8; let svx=this.vx/steps; let svy=this.vy/steps;
            if(this.vx === 0 && this.vy === 0 && this.type === 'fragment') return;
            for(let k=0; k<steps; k++){
                this.x+=svx; this.y+=svy;
                if(checkWallCollision(this.x, this.y, this.radius)) {
                    createHitEffect(this.x, this.y, this.color);
                    
                    if(this.type === 'missile' || this.type === 'frag') {
                        this.x -= svx; this.y -= svy;
                        if (checkWallCollision(this.x + svx, this.y, this.radius)) { this.vx = -this.vx; svx = -svx; }
                        else { this.vy = -this.vy; svy = -svy; }
                        this.angle = Math.atan2(this.vy, this.vx);
                        return; 
                    }
                    this.x -= svx; this.y -= svy;
                    if (checkWallCollision(this.x + svx, this.y, this.radius)) { this.vx = -this.vx; svx = -svx; }
                    else { this.vy = -this.vy; svy = -svy; }
                    if (this.type !== 'fragment' && this.type !== 'missile' && this.type !== 'frag') this.owner = null;
                    this.angle = Math.atan2(this.vy, this.vx);
                    break;
                }
            }
        }
        draw() { 
            if (this.type === 'mine' && !this.visible) return;
            ctx.save(); ctx.translate(this.x, this.y);
            if(this.type === 'fragment') { if(this.life < 60) ctx.globalAlpha = this.life / 60; }
            ctx.rotate(this.angle); 
            if(this.type === 'mini') { ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(4, 0); ctx.lineTo(-4, -2); ctx.lineTo(-4, 2); ctx.fill(); } 
            else if(this.type === 'frag') { ctx.fillStyle = (Math.floor(this.life/10)%2===0) ? "#fff" : this.color; ctx.beginPath(); ctx.arc(0,0,5,0,Math.PI*2); ctx.fill(); ctx.strokeStyle = "#fff"; ctx.lineWidth=1; ctx.stroke(); } 
            else if(this.type === 'flame') {
                let alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = (this.life > 30) ? '#ffff00' : '#ff5722'; // Yellow to Orange
                ctx.shadowBlur = 10; ctx.shadowColor = '#ff5722';
                ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            }
            else if(this.type === 'missile') {
                ctx.fillStyle = "#ccc"; ctx.fillRect(-6, -3, 10, 6); ctx.fillStyle = "red"; ctx.beginPath(); ctx.moveTo(4, -3); ctx.lineTo(10, 0); ctx.lineTo(4, 3); ctx.fill();
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(-6, 0); ctx.lineTo(-10, -5); ctx.lineTo(-2, -3); ctx.fill(); ctx.beginPath(); ctx.moveTo(-6, 0); ctx.lineTo(-10, 5); ctx.lineTo(-2, 3); ctx.fill();
                ctx.fillStyle = "#ffaa00"; ctx.beginPath(); ctx.moveTo(-6, 0); ctx.lineTo(-12, -2); ctx.lineTo(-12, 2); ctx.fill();
                if (this.maxLife - this.life > 180) ctx.fillStyle = "red"; else ctx.fillStyle = "#00ff00"; ctx.beginPath(); ctx.arc(0, 0, 2, 0, Math.PI*2); ctx.fill();
            } 
            else if(this.type === 'fragment') { ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(6, 0); ctx.lineTo(-4, -4); ctx.lineTo(-4, 4); ctx.fill(); } 
            else if (this.type === 'mine') { if (Math.floor(this.armingTime / 10) % 2 === 0) { ctx.fillStyle = "red"; } else { ctx.fillStyle = "#222"; } ctx.fillRect(-6,-6,12,12); ctx.strokeStyle="red"; ctx.lineWidth=1; ctx.strokeRect(-6,-6,12,12); } 
            else { ctx.shadowBlur = 6; ctx.shadowColor = this.color; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.fill(); ctx.shadowBlur = 0; }
            ctx.restore();
        }
    }

    class Tank {
        constructor(x, y, color, name, ctrls, uiId, isAI=false) {
            this.startX=x; this.startY=y; this.color=color; this.name=name; this.ctrls=ctrls; this.uiId=uiId;
            this.pKey = name === "P1" ? "p1" : "p2"; 
            this.isAI = isAI;
            this.reset();
        }
        reset() {
            this.x=this.startX; this.y=this.startY; this.angle=Math.random()*Math.PI*2;
            this.dead=false; this.hitbox=8; this.setWeapon('NORMAL');
            this.reloadTimer=0; this.spinning = false; this.spinTimer = 0;
            this.activeShield = false; this.shieldTimer = 0;
            this.cachedAmmo = -1; this.cachedWeapon = '';
            this.currentVx = 0; this.currentVy = 0;
            this.aiPathTimer = 0; this.aiCurrentPath = []; this.aiTargetCell = null;
            this.trackTimer = 0;
            this.needsTriggerReset = false; // MOD: New flag for trigger reset
            
            // AI Specific
            this.aiMode = 'SEEK'; // 'SEEK', 'AIM_LOCK'
            this.aiAimLockTimer = 0;
            this.aiIdealAngle = 0;
            this.aiReactionCounter = 0;
        }
        setWeapon(type) { this.weaponType = type; this.ammo = WEAPONS[type].ammo; this.maxAmmo = WEAPONS[type].ammo; this.cooldownTimer=0; }
        takeDamage(killer, bullet) {
            if (this.dead || roundEnding) return; 
            if (this.activeShield) {
                createSparks(this.x, this.y, "#ffffff", 8);
                if (bullet && bullet.type !== 'mine' && !bullet.dead) {
                    bullet.owner = this; bullet.vx = -bullet.vx * 1.1; bullet.vy = -bullet.vy * 1.1;
                    bullet.angle = Math.atan2(bullet.vy, bullet.vx); bullet.x += bullet.vx * 2; bullet.y += bullet.vy * 2; bullet.life += 60; 
                }
                return;
            }
            this.dead = true;
            createExplosion(this.x, this.y, this.color, true);
            if (bullet) bullet.dead = true;
            
            if(killer && killer !== this) {
                triggerAICommentary('kill', { killer: killer.name, victim: this.name, weapon: killer.weaponType });
            }
            
            if (p1.dead && p2.dead) {
                if(roundEndTimer) clearTimeout(roundEndTimer); roundEnding = true;
                msgBox.innerText = "DRAW!"; msgBox.style.color = "#fff"; msgBox.style.display = "block"; setTimeout(resetRound, 2000);
            } else {
                roundEndTimer = setTimeout(() => {
                    roundEnding = true;
                    if (p1.dead && !p2.dead) { 
                        scores.p2++; 
                        msgBox.innerText = "RED WINS!"; msgBox.style.color = "#d32f2f"; 
                        triggerAICommentary('win', { winner: "Red Player" });
                    }
                    else if (p2.dead && !p1.dead) { 
                        scores.p1++; 
                        msgBox.innerText = "GREEN WINS!"; msgBox.style.color = "#4CAF50";
                        triggerAICommentary('win', { winner: "Green Player" });
                    }
                    document.getElementById('s1').innerText = scores.p1; document.getElementById('s2').innerText = scores.p2;
                    msgBox.style.display = "block"; setTimeout(resetRound, 2000);
                }, 3000);
            }
        }
        update(walls, powerups) {
            if(this.dead) return;
            if(this.cooldownTimer>0) this.cooldownTimer--;
            if (this.activeShield) { this.shieldTimer--; if (this.shieldTimer <= 0) { this.activeShield = false; } }
            if (this.spinning) {
                this.angle += 0.01; this.spinTimer--;
                activeLasers.push(new LaserBeam(this.x, this.y, this.angle, this, 2)); activeLasers.push(new LaserBeam(this.x, this.y, this.angle + Math.PI, this, 2));
                if(this.spinTimer % 10 === 0) createSparks(this.x, this.y, WEAPONS.DEATHRAY.color, 2);
                if (this.spinTimer <= 0) { 
                    this.spinning = false; 
                    this.setWeapon('NORMAL'); 
                    this.needsTriggerReset = true; // MOD: Force reset after deathray
                }
                return;
            }
            
            // RELOAD LOGIC
            if(this.weaponType==='NORMAL' && this.ammo<this.maxAmmo) { 
                this.reloadTimer++; if(this.reloadTimer>=RELOAD_TIME){ this.ammo++; this.reloadTimer=0; } 
            } else this.reloadTimer=0;
            
            // MODIFIED: WEAPON DEPLETION LOGIC (Forces Trigger Reset)
            if(this.weaponType!=='NORMAL' && this.ammo<=0) {
                this.setWeapon('NORMAL');
                this.needsTriggerReset = true; // Flag to stop auto-shooting normal ammo
            }

            // --- MOVEMENT LOGIC ---
            if (!this.isAI) {
                let spd = 0;
                let firing = false;

                if (isMobile) {
                    let input = this.pKey === 'p1' ? mobileInput.p1 : mobileInput.p2;
                    if (Math.abs(input.x) > 0.1 || Math.abs(input.y) > 0.1) {
                         let targetAngle = Math.atan2(input.y, input.x);
                         let diff = targetAngle - this.angle;
                         while(diff < -Math.PI) diff += Math.PI*2; while(diff > Math.PI) diff -= Math.PI*2;
                         let sens = mobileSettings[this.pKey].sensitivity;
                         this.angle += Math.sign(diff) * Math.min(Math.abs(diff), 0.1 * sens);
                         spd = 2; 
                    }
                    if (input.fire) firing = true;
                }  else {
                    let c = controls[this.pKey];
                    if(keys[c.left]) this.angle-=0.05; if(keys[c.right]) this.angle+=0.05;
                    if(keys[c.up]) spd=2; else if(keys[c.down]) spd=-2;
                    if (keys[c.shoot]) firing = true;
                }
                
                // MODIFIED: TRIGGER RESET CHECK
                if (this.needsTriggerReset) {
                    if (!firing) {
                        this.needsTriggerReset = false; // Released! Reset flag
                    } else {
                        firing = false; // Block shooting until released
                    }
                }

                if (firing) this.shoot(walls);

                if(spd!==0) {
                    this.currentVx = Math.cos(this.angle)*spd; this.currentVy = Math.sin(this.angle)*spd;
                    if(!checkWallCollision(this.x + this.currentVx, this.y, this.hitbox)) { this.x += this.currentVx; }
                    if(!checkWallCollision(this.x, this.y + this.currentVy, this.hitbox)) { this.y += this.currentVy; }
                    this.drawTracks();
                }
            } 

            for(let p of powerups) {
                if(p.active && Math.hypot(this.x-p.x, this.y-p.y)<20) {
                    if (this.weaponType !== 'NORMAL') continue;
                    if (p.type === 'SHIELD') { this.activeShield = false; }
                    p.active = false; this.setWeapon(p.type); createHitEffect(this.x,this.y);
                }
            }
        }
        drawTracks() {
            this.trackTimer++;
            if (this.trackTimer % 8 === 0) {
                tracks.push(new TrackMark(this.x, this.y, this.angle));
            }
        }
        shoot(walls) {
            if(this.dead || this.ammo<=0 || this.cooldownTimer>0) return;
            if (this.weaponType === 'SHIELD') {
                this.activeShield = true; this.shieldTimer = 5 * 60; this.setWeapon('NORMAL'); this.ammo = 5; this.cachedAmmo = -1; 
                this.needsTriggerReset = true; // Also force reset for shield use
                createSparks(this.x, this.y, "#fff", 30); return; 
            }
            if (this.weaponType === 'MINE') {
                let mx = this.x - Math.cos(this.angle) * 26; let my = this.y - Math.sin(this.angle) * 26;
                if (checkWall(mx, my, 8)) return; 
                bullets.push(new Bullet(mx, my, 0, WEAPONS.MINE.color, 'mine', this));
                this.cooldownTimer = WEAPONS.MINE.cooldown; this.ammo--; return;
            }

            let muzzleDist = 20; let tipX = this.x + Math.cos(this.angle) * muzzleDist; let tipY = this.y + Math.sin(this.angle) * muzzleDist;
            let midX = this.x + Math.cos(this.angle) * (muzzleDist/2); let midY = this.y + Math.sin(this.angle) * (muzzleDist/2);
            let ignoreWallBlock = (this.weaponType === 'DEATHRAY' || this.weaponType === 'LASER' || this.weaponType === 'FLAME');
            
            if (!ignoreWallBlock) {
                if(checkWallCollision(tipX, tipY, 2) || checkWallCollision(midX, midY, 2)) {
                    createExplosion(this.x, this.y, this.color); this.takeDamage(this, null); return; 
                }
            }

            if(this.weaponType === 'LASER') {
                activeLasers.push(new LaserBeam(this.x, this.y, this.angle, this)); shakeAmount = 10; this.cooldownTimer = WEAPONS.LASER.cooldown; 
            } else if (this.weaponType === 'DEATHRAY') {
                this.spinning = true; this.spinTimer = 314; 
            } else if(this.weaponType === 'TRIPLE') {
                let spread = 0.26; 
                bullets.push(new Bullet(tipX, tipY, this.angle, WEAPONS.NORMAL.color, 'normal', this));
                bullets.push(new Bullet(tipX, tipY, this.angle - spread, WEAPONS.NORMAL.color, 'normal', this));
                bullets.push(new Bullet(tipX, tipY, this.angle + spread, WEAPONS.NORMAL.color, 'normal', this));
                this.cooldownTimer = WEAPONS.TRIPLE.cooldown;
            } else if (this.weaponType === 'MISSILE') {
                bullets.push(new Bullet(tipX, tipY, this.angle, WEAPONS.MISSILE.color, 'missile', this));
                this.cooldownTimer = WEAPONS.MISSILE.cooldown;
            } else if (this.weaponType === 'FLAME') {
                let spread = (Math.random() - 0.5) * 0.4; // Wide spread
                bullets.push(new Bullet(tipX, tipY, this.angle + spread, WEAPONS.FLAME.color, 'flame', this));
                this.cooldownTimer = WEAPONS.FLAME.cooldown;
            } else {
                let mx=this.x+Math.cos(this.angle)*18, my=this.y+Math.sin(this.angle)*18;
                if(this.weaponType === 'GATLING') {
                    let spread = (Math.random()-0.5)*0.2; bullets.push(new Bullet(mx,my,this.angle+spread, WEAPONS.GATLING.color, 'mini', this)); this.cooldownTimer = WEAPONS.GATLING.cooldown;
                } else if(this.weaponType === 'FRAG') {
                    bullets.push(new Bullet(mx,my,this.angle, WEAPONS.FRAG.color, 'frag', this)); this.cooldownTimer = WEAPONS.FRAG.cooldown;
                } else {
                    bullets.push(new Bullet(mx,my,this.angle,this.color, 'normal', this)); this.cooldownTimer = WEAPONS.NORMAL.cooldown;
                }
            }
            if (this.weaponType !== 'DEATHRAY') this.ammo--;
        }
        draw() {
            if(this.dead) return;
            ctx.fillStyle="#fff"; ctx.font="bold 10px Arial"; ctx.textAlign="center"; ctx.fillText(this.name, this.x, this.y-28);
            if(this.weaponType==='NORMAL' && this.ammo < this.maxAmmo) { 
                ctx.fillStyle="#444"; ctx.fillRect(this.x-12,this.y-24,24,4); 
                ctx.fillStyle=this.color; ctx.fillRect(this.x-12,this.y-24,24*(this.reloadTimer/RELOAD_TIME),4); 
                ctx.strokeStyle="#000"; ctx.lineWidth=1; ctx.strokeRect(this.x-12.5,this.y-24.5,25,5);
            }
            ctx.save(); ctx.translate(this.x, this.y); 
            if (this.activeShield) { 
                ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0,0,24,0,Math.PI*2); ctx.stroke(); 
                ctx.fillStyle = "rgba(255,255,255,0.1)"; ctx.fill();
            }
            ctx.rotate(this.angle);
            ctx.shadowColor="rgba(0,0,0,0.5)"; ctx.shadowBlur=6; ctx.shadowOffsetY=3;
            ctx.fillStyle = "#222"; ctx.fillRect(-14, -14, 28, 8); ctx.fillStyle = "#111"; for(let i=-12; i<12; i+=4) ctx.fillRect(i, -14, 2, 8);
            ctx.fillStyle = "#222"; ctx.fillRect(-14, 6, 28, 8); ctx.fillStyle = "#111"; for(let i=-12; i<12; i+=4) ctx.fillRect(i, 6, 2, 8);
            ctx.shadowBlur=0; ctx.shadowOffsetY=0; ctx.fillStyle = "#333"; ctx.fillRect(-12, -7, 24, 14); 
            ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(-10, -5); ctx.lineTo(10, -5); ctx.lineTo(12, 0); ctx.lineTo(10, 5); ctx.lineTo(-10, 5); ctx.closePath(); ctx.fill();
            let recoil = 0;
            if(this.weaponType === 'NORMAL' && this.reloadTimer < 5) recoil = this.reloadTimer;
            if(this.weaponType === 'GATLING' && this.cooldownTimer > 0) recoil = Math.random() * 2;
            ctx.save(); ctx.translate(-recoil, 0); 
            drawTurret(ctx, this.weaponType, this.color);
            ctx.restore(); 
            ctx.fillStyle = this.color; ctx.filter = "brightness(80%)"; ctx.beginPath(); ctx.arc(0, 0, 7, 0, Math.PI*2); ctx.fill(); ctx.filter = "none";
            ctx.strokeStyle = "rgba(0,0,0,0.5)"; ctx.lineWidth = 1; ctx.stroke();
            ctx.fillStyle = "rgba(255,255,255,0.3)"; ctx.beginPath(); ctx.arc(3, -2, 2, 0, Math.PI*2); ctx.fill();
            if (this.weaponType === 'SHIELD' && !this.activeShield) { ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.stroke(); }
            ctx.restore();
        }
    }

    function drawTurret(ctx, type, color) {
        switch(type) {
            case 'GATLING': ctx.fillStyle = "#222"; ctx.fillRect(0, -5, 18, 10); ctx.fillStyle = "#555"; ctx.fillRect(18, -4, 10, 2); ctx.fillRect(18, 2, 10, 2); ctx.fillStyle = WEAPONS.GATLING.color; ctx.fillRect(18, -1, 12, 2); ctx.fillStyle = "#888"; ctx.fillRect(22, -5, 2, 10); break;
            case 'FRAG': ctx.fillStyle = "#222"; ctx.fillRect(0, -6, 12, 12); ctx.fillStyle = "#444"; ctx.beginPath(); ctx.moveTo(10, -4); ctx.lineTo(22, -7); ctx.lineTo(22, 7); ctx.lineTo(10, 4); ctx.fill(); ctx.fillStyle = WEAPONS.FRAG.color; ctx.fillRect(20, -6, 2, 12); break;
            case 'LASER': ctx.fillStyle = "#222"; ctx.fillRect(0, -5, 15, 10); ctx.fillStyle = "#555"; ctx.fillRect(10, -6, 20, 3); ctx.fillRect(10, 3, 20, 3); ctx.fillStyle = WEAPONS.LASER.color; ctx.globalAlpha = 0.8; ctx.fillRect(5, -1, 24, 2); ctx.globalAlpha = 1.0; break;
            case 'TRIPLE': ctx.fillStyle = "#222"; ctx.fillRect(0, -6, 14, 12); ctx.fillStyle = "#555"; ctx.fillRect(14, -2, 16, 4); ctx.save(); ctx.translate(10, 0); ctx.rotate(-0.3); ctx.fillRect(0, -2, 14, 4); ctx.restore(); ctx.save(); ctx.translate(10, 0); ctx.rotate(0.3); ctx.fillRect(0, -2, 14, 4); ctx.restore(); ctx.fillStyle = WEAPONS.TRIPLE.color; ctx.fillRect(28, -2, 2, 4); break;
            case 'DEATHRAY': ctx.fillStyle = "#222"; ctx.fillRect(0, -4, 10, 8); ctx.fillStyle = "#444"; ctx.beginPath(); ctx.arc(15, 0, 12, -Math.PI/2, Math.PI/2, false); ctx.fill(); ctx.fillStyle = WEAPONS.DEATHRAY.color; ctx.beginPath(); ctx.arc(15, 0, 8, -Math.PI/2, Math.PI/2, false); ctx.fill(); break;
            case 'MISSILE': ctx.fillStyle = "#222"; ctx.fillRect(0, -6, 10, 12); ctx.fillStyle = "#555"; ctx.fillRect(5, -8, 14, 6); ctx.fillRect(5, 2, 14, 6); ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(12, -5, 2, 0, Math.PI*2); ctx.arc(12, 5, 2, 0, Math.PI*2); ctx.fill(); break;
            case 'MINE': ctx.fillStyle = "#222"; ctx.fillRect(0, -3, 16, 6); ctx.fillStyle = "#000"; ctx.fillRect(-14, -6, 6, 12); ctx.strokeStyle = "red"; ctx.strokeRect(-14, -6, 6, 12); break;
            case 'SHIELD': ctx.fillStyle = "#222"; ctx.fillRect(0, -3, 20, 6); ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(10, 0, 4, 0, Math.PI*2); ctx.fill(); break;
            case 'FLAME': ctx.fillStyle = "#222"; ctx.fillRect(0, -5, 14, 10); ctx.fillStyle = "#333"; ctx.fillRect(14, -6, 4, 12); ctx.fillStyle = "#ff5722"; ctx.fillRect(18, -4, 4, 8); ctx.fillStyle = "#ff9800"; ctx.beginPath(); ctx.arc(20, 0, 2, 0, Math.PI*2); ctx.fill(); break;
            case 'NORMAL': default: ctx.fillStyle="#222"; ctx.fillRect(0,-3,24,6); ctx.fillStyle="#111"; ctx.fillRect(22,-4,4,8); ctx.fillStyle="#ccc"; ctx.fillRect(0,-1,10,2); break;
        }
        ctx.shadowBlur = 0; 
    }

    // --- STRATEGIC AI SYSTEM (THE MAGIC AIM V3) ---
    function updateAI(ai, opponent) {
        if(ai.dead || opponent.dead) return;
        
        // 0. CONFIG FETCH
        const diff = AI_DIFFICULTY[aiConfig.difficulty] || AI_DIFFICULTY.NORMAL;
        const persona = AI_PERSONALITY[aiConfig.personality] || AI_PERSONALITY.BALANCED;

        // 1. REACTION DELAY (Simulate human lag)
        ai.aiReactionCounter++;
        if (ai.aiReactionCounter < diff.reaction) {
            // S·ª¨A: Thay v√¨ tr∆∞·ª£t ƒëi ti·∫øp (g√¢y c·∫£m gi√°c ƒëi ngang), AI s·∫Ω kh·ª±ng l·∫°i ho·∫∑c ƒëi ch·∫≠m khi ƒëang suy nghƒ©
            ai.currentVx *= 0.8; 
            ai.currentVy *= 0.8;
            
            if(!checkWallCollision(ai.x + ai.currentVx, ai.y + ai.currentVy, ai.hitbox)) {
               ai.x += ai.currentVx; ai.y += ai.currentVy;
            }
            return;
        }
        ai.aiReactionCounter = 0;

        // 2. AIM LOCK STATE
        if (ai.aiAimLockTimer > 0) {
            ai.aiAimLockTimer--;
            // Add Aim Error (Jitter)
            let error = (Math.random() - 0.5) * diff.aimErr;
            rotateTowards(ai, ai.aiIdealAngle + error, 0.25); 
            
            if (ai.aiAimLockTimer <= 0 || Math.abs(ai.aiIdealAngle - ai.angle) < 0.1) {
                ai.shoot(walls);
                ai.aiMode = 'SEEK';
            }
            return; 
        }

        // 3. MAGIC AIM CHECK
        // If ammo available and gun ready
        if (ai.ammo > 0 && ai.cooldownTimer <= 0) {
            // SPECIAL CHECK FOR FLAME (Short Range)
            if (ai.weaponType === 'FLAME') {
                // Only shoot if target is close (approx 150px) and visible
                let d = dist(ai.x, ai.y, opponent.x, opponent.y);
                if (d < 160 && hasLineOfSight(ai.x, ai.y, opponent.x, opponent.y)) {
                    // Just aim directly at opponent
                    ai.aiIdealAngle = Math.atan2(opponent.y - ai.y, opponent.x - ai.x);
                    ai.aiAimLockTimer = 5;
                    ai.aiMode = 'AIM_LOCK';
                    return;
                }
                // If not close, don't try to find firing solution, just move closer
            } else {
                // Updated: Pass 'ai' itself to check for self-damage
                let magicAngle = findFiringSolution(ai, opponent, diff.bounces);
                if (magicAngle !== null) {
                    ai.aiIdealAngle = magicAngle;
                    ai.aiAimLockTimer = 15; // Lock duration
                    ai.aiMode = 'AIM_LOCK';
                    return;
                }
            }
        }

        // 4. STRATEGIC MOVEMENT
        let moveTarget = {x: opponent.x, y: opponent.y};
        let shouldMove = true;

        // -- BEHAVIOR LOGIC --
        // CAMPER: Only move if ammo low or weapon is normal
        if (persona.type === 'camper') {
            if (ai.weaponType !== 'NORMAL' && ai.ammo > 0) {
                // Find a corner or stay put? For now, stay put if not threatened
                if (Math.random() < 0.95) shouldMove = false;
            }
        }
        
        // SNIPER: Keep distance
        if (persona.type === 'sniper') {
            let d = dist(ai.x, ai.y, opponent.x, opponent.y);
            if (d < 400 && ai.ammo > 0 && ai.weaponType !== 'NORMAL') {
                // Retreat logic? Simple stop for now, maybe back up later
                // Actually, finding a path AWAY is hard with just A*, let's just hold position
                // or move to a powerup far away
            }
        }

        // POWERUP SEEKING (Universal Priority)
        // If ammo low or weapon weak, look for powerups
        if (ai.weaponType === 'NORMAL' || ai.ammo <= 1 || persona.type === 'rusher') {
            let minP = 9999, bestP = null;
            for(let p of powerups) {
                if(p.active) {
                    let d = dist(ai.x, ai.y, p.x, p.y);
                    if(d < minP) { minP = d; bestP = p; }
                }
            }
            // Rusher grabs powerups on the way, but prioritizes player if close
            if (bestP) {
                // If Rusher and player is VERY close, ignore powerup
                if (persona.type === 'rusher' && dist(ai.x, ai.y, opponent.x, opponent.y) < 200) {
                    moveTarget = {x: opponent.x, y: opponent.y};
                } else {
                    moveTarget = {x: bestP.x, y: bestP.y};
                }
            }
        }

        if (!shouldMove) {
            // Just look at opponent
            let ang = Math.atan2(opponent.y - ai.y, opponent.x - ai.x);
            rotateTowards(ai, ang, 0.1);
            return;
        }

        // Pathfinding Logic
        let directVis = hasLineOfSight(ai.x, ai.y, moveTarget.x, moveTarget.y);
        
        if (!directVis) {
            if (ai.aiPathTimer++ % 20 === 0 || ai.aiCurrentPath.length === 0) { 
                ai.aiCurrentPath = getBFSPath(ai.x, ai.y, moveTarget.x, moveTarget.y); 
                ai.aiTargetCell = 0; 
            }
            
            if (ai.aiCurrentPath.length > 0) {
                let cell = ai.aiCurrentPath[ai.aiTargetCell];
                if (cell) {
                    let nextX = cell.x * cellSize + cellSize/2; 
                    let nextY = cell.y * cellSize + cellSize/2;
                    if (dist(ai.x, ai.y, nextX, nextY) < 30) { 
                        ai.aiTargetCell++; 
                        if (ai.aiTargetCell >= ai.aiCurrentPath.length) ai.aiCurrentPath = []; 
                    } else { 
                        moveTarget = {x: nextX, y: nextY}; 
                    }
                }
            }
        } else {
             ai.aiCurrentPath = []; 
        }

        let dx = moveTarget.x - ai.x; 
        let dy = moveTarget.y - ai.y;
        let moveAngle = Math.atan2(dy, dx);
        
        rotateTowards(ai, moveAngle, 0.15); 
        
        let diffMove = moveAngle - ai.angle;
        while(diffMove < -Math.PI) diffMove += Math.PI*2; while(diffMove > Math.PI) diffMove -= Math.PI*2;
        
        // S·ª¨A: Gi·∫£m g√≥c cho ph√©p di chuy·ªÉn t·ª´ 1.0 (57 ƒë·ªô) xu·ªëng 0.5 (28 ƒë·ªô)
        // Xe tƒÉng s·∫Ω xoay ng∆∞·ªùi th·∫≥ng h∆°n r·ªìi m·ªõi ƒëi, tr√°nh hi·ªán t∆∞·ª£ng "drift" ngang
        if (Math.abs(diffMove) < 0.5) {
            let speed = (ai.activeShield ? 3.5 : diff.moveSpeed);
            ai.currentVx = Math.cos(ai.angle) * speed; 
            ai.currentVy = Math.sin(ai.angle) * speed;
            
            if(!checkWallCollision(ai.x + ai.currentVx, ai.y, ai.hitbox)) { ai.x += ai.currentVx; }
            if(!checkWallCollision(ai.x, ai.y + ai.currentVy, ai.hitbox)) { ai.y += ai.currentVy; }
            ai.drawTracks();
        }
    }

    function findFiringSolution(ai, target, maxBounces) {
        let distToTarget = dist(ai.x, ai.y, target.x, target.y);
        let timeToImpact = distToTarget / 3.0; 
        let predX = target.x + target.currentVx * timeToImpact; 
        let predY = target.y + target.currentVy * timeToImpact;
        
        if (!hasLineOfSight(ai.x, ai.y, predX, predY)) {
            // Only try bouncing if enabled for difficulty
            if (maxBounces > 0) {
                for (let a = 0; a < 360; a += 10) {
                    let rad = a * (Math.PI / 180);
                    // UPDATE: Pass 'ai' as the shooter argument
                    if (simulateBullet(ai.x, ai.y, rad, target, maxBounces, ai)) {
                        return rad; 
                    }
                }
            }
        } else {
            return Math.atan2(predY - ai.y, predX - ai.x);
        }
        return null;
    }

    // UPDATE: Added 'shooter' parameter
    function simulateBullet(startX, startY, angle, target, maxBounces, shooter) {
        let x = startX, y = startY;
        let vx = Math.cos(angle) * 3, vy = Math.sin(angle) * 3;
        let bounces = 0;
        const steps = 200; 

        for (let i = 0; i < steps; i++) {
            for(let k=0; k<4; k++) {
                x += vx; y += vy;
                
                // Wall Collision
                if (checkWallCollision(x, y, 2.5)) {
                    if (bounces >= maxBounces) return false;
                    bounces++;
                    x -= vx; y -= vy;
                    if (checkWallCollision(x + vx, y, 2.5)) { vx = -vx; } else { vy = -vy; }
                    x += vx; y += vy; 
                }
                
                // Target Hit Check
                if (dist(x, y, target.x, target.y) < 20) return true; 

                // NEW: Self-Hit Safety Check
                // N·∫øu ƒë·∫°n quay l·∫°i g·∫ßn ng∆∞·ªùi b·∫Øn (shooter) V√Ä (ƒë√£ n·∫£y t∆∞·ªùng HO·∫∂C ƒë√£ bay xa kh·ªèi n√≤ng s√∫ng > 35px)
                if (shooter) {
                    let dToSelf = dist(x, y, shooter.x, shooter.y);
                    if (dToSelf < 20 && (bounces > 0 || dist(x, y, startX, startY) > 35)) {
                        return false; // Nguy hi·ªÉm! ƒê·∫°n s·∫Ω tr√∫ng m√¨nh -> H·ªßy g√≥c b·∫Øn n√†y
                    }
                }
            }
        }
        return false;
    }

    function rotateTowards(obj, targetAngle, speed) {
        let diff = targetAngle - obj.angle;
        while(diff < -Math.PI) diff += Math.PI*2; while(diff > Math.PI) diff -= Math.PI*2;
        obj.angle += Math.sign(diff) * Math.min(Math.abs(diff), speed);
    }

    // --- SETTINGS UI LOGIC ---
    function renderWeaponSettings() {
        // Reset Weights
        pendingWeights = {};
        
        const mainPanel = document.getElementById('mainSettingsPanel');
        if (!mainPanel) return; // FIX: Ensure panel exists
        
        let html = `
            <div class="settings-header-fixed">
                <div class="panel-header" style="margin:0; border:none; padding:0;">MATCH CONFIGURATION</div>
            </div>
            
            <div class="settings-scroll-area">
                <!-- GROUP 1: GAME RULES -->
                <div class="settings-group">
                    <div class="group-title">GAME RULES</div>
                    <div class="compact-row">
                        <span class="compact-label">Spawn Interval</span>
                        <div style="flex:1; margin:0 10px;"><input type="range" min="1" max="60" value="${gameSettings.spawnTime}" class="custom-range" oninput="window.updateCustom(this, 'time')"></div>
                        <span class="compact-val" id="valSpawnTime">${gameSettings.spawnTime}s</span>
                    </div>
                    <div class="compact-row">
                        <span class="compact-label">Max Items</span>
                        <div style="flex:1; margin:0 10px;"><input type="range" min="1" max="50" value="${gameSettings.maxItems}" class="custom-range" oninput="window.updateCustom(this, 'max')"></div>
                        <span class="compact-val" id="valMaxItems">${gameSettings.maxItems}</span>
                    </div>
                </div>

                <!-- GROUP 2: AI BRAIN -->
                <div class="settings-group">
                    <div class="group-title">MAGIC AI BRAIN</div>
                    <div class="compact-row">
                        <span class="compact-label">DIFFICULTY</span>
                        <div style="text-align:right;">
                            <button class="cycle-btn" onclick="window.cycleAI('difficulty')">${aiConfig.difficulty}</button>
                            <div style="font-size:9px; color:#666; margin-top:2px;">${getDiffDesc()}</div>
                        </div>
                    </div>
                    <div class="compact-row" style="margin-top:5px;">
                        <span class="compact-label">BEHAVIOR</span>
                        <button class="cycle-btn" onclick="window.cycleAI('personality')">${AI_PERSONALITY[aiConfig.personality].label}</button>
                    </div>
                </div>

                <!-- GROUP 3: WEAPON POOL -->
                <div class="settings-group">
                    <div class="group-title">WEAPON DROP CHANCE (%)</div>
                    <div id="weaponListInternal">
        `;

        // Generate Weapon List
        let weaponListHtml = "";
        POWERUP_TYPES.forEach(key => {
            const w = WEAPONS[key];
            pendingWeights[key] = w.weight;
            weaponListHtml += `
                <div class="weapon-row">
                    <div class="weapon-name" style="color:${w.color}">${key}</div>
                    <input type="range" min="0" max="100" value="${w.weight}" class="custom-range" id="slider_${key}" oninput="window.updateCustom(this, 'weaponWeight', '${key}')">
                    <input type="number" min="0" max="100" value="${w.weight}" class="custom-num-input" id="input_${key}" oninput="window.updateCustom(this, 'weaponWeightInput', '${key}')">
                </div>
            `;
        });

        html += weaponListHtml + `
                    </div>
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #333;">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                            <span style="font-size:10px; font-weight:bold; color:#888;">TOTAL RATE:</span>
                            <span id="totalDropRate" style="font-size:11px; font-weight:bold;">100%</span>
                        </div>
                        <button id="btnApplyRates" class="btn-apply valid" onclick="window.applyDropRates()">APPLY CHANGES</button>
                    </div>
                </div>
            </div>
        `;

        mainPanel.innerHTML = html;
        validateTotalDropRate();
    }

    function cycleAI(type) {
        const diffKeys = Object.keys(AI_DIFFICULTY);
        const persKeys = Object.keys(AI_PERSONALITY);
        
        if (type === 'difficulty') {
            let idx = diffKeys.indexOf(aiConfig.difficulty);
            idx = (idx + 1) % diffKeys.length;
            aiConfig.difficulty = diffKeys[idx];
        } else {
            let idx = persKeys.indexOf(aiConfig.personality);
            idx = (idx + 1) % persKeys.length;
            aiConfig.personality = persKeys[idx];
        }
        renderWeaponSettings(); // Re-render to update text
    }

    function getDiffDesc() {
        switch(aiConfig.difficulty) {
            case 'EASY': return "Slow, Poor Aim";
            case 'NORMAL': return "Standard, 1 Bounce";
            case 'HARD': return "Fast, 2 Bounces";
            case 'INSANE': return "Cheater Mode";
            default: return "";
        }
    }

    // --- A* ALGORITHM ---
    function getAStarPath(startX, startY, targetX, targetY) {
        let cols = Math.floor(canvas.width / cellSize);
        let rows = Math.floor(canvas.height / cellSize);
        
        let startCol = Math.floor(startX / cellSize);
        let startRow = Math.floor(startY / cellSize);
        let endCol = Math.floor(targetX / cellSize);
        let endRow = Math.floor(targetY / cellSize);

        // Safety checks
        if (startCol < 0 || startCol >= cols || startRow < 0 || startRow >= rows) return [];
        if (endCol < 0 || endCol >= cols || endRow < 0 || endRow >= rows) return [];
        if (startCol === endCol && startRow === endRow) return [];

        let startNode = { c: startCol, r: startRow, g: 0, f: 0 };
        let openSet = [startNode];
        let cameFrom = {}; // Key: "c,r", Value: {c, r}
        let gScore = {}; // Key: "c,r", Value: cost
        
        let startKey = startCol + "," + startRow;
        gScore[startKey] = 0;

        // Heuristic function (Euclidean distance)
        const heuristic = (c1, r1, c2, r2) => {
            return Math.hypot(c1 - c2, r1 - r2);
        };

        startNode.f = heuristic(startCol, startRow, endCol, endRow);

        let visitedCount = 0;

        while (openSet.length > 0) {
            visitedCount++;
            if (visitedCount > 1000) break; // Emergency break

            // Get node with lowest fScore
            let currentIdx = 0;
            for (let i = 1; i < openSet.length; i++) {
                if (openSet[i].f < openSet[currentIdx].f) currentIdx = i;
            }
            let current = openSet[currentIdx];

            // Check if reached target
            if (current.c === endCol && current.r === endRow) {
                // Reconstruct path
                let path = [];
                let currKey = current.c + "," + current.r;
                while (cameFrom[currKey]) {
                    path.push({ x: parseInt(currKey.split(',')[0]), y: parseInt(currKey.split(',')[1]) });
                    let prev = cameFrom[currKey];
                    currKey = prev.c + "," + prev.r;
                }
                // path.push({ x: startCol, y: startRow }); // Optional: include start
                return path.reverse();
            }

            openSet.splice(currentIdx, 1); // Remove current from openSet

            // Get neighbors
            let idx = current.c + current.r * cols;
            if (idx < 0 || idx >= mazeGrid.length) continue;
            let cell = mazeGrid[idx];
            
            let neighbors = [];
            // Check walls: 0:Top, 1:Right, 2:Bottom, 3:Left. 
            // Note: mazeGrid.w[d] === 0 means NO WALL (passable). 1 means WALL.
            
            // Top
            if (cell.w[0] === 0) neighbors.push({ c: current.c, r: current.r - 1 });
            // Right
            if (cell.w[1] === 0) neighbors.push({ c: current.c + 1, r: current.r });
            // Bottom
            if (cell.w[2] === 0) neighbors.push({ c: current.c, r: current.r + 1 });
            // Left
            if (cell.w[3] === 0) neighbors.push({ c: current.c - 1, r: current.r });

            for (let neighbor of neighbors) {
                // Bounds check
                if (neighbor.c < 0 || neighbor.c >= cols || neighbor.r < 0 || neighbor.r >= rows) continue;

                let tentativeG = gScore[current.c + "," + current.r] + 1; // Distance between neighbors is 1 grid unit
                let neighborKey = neighbor.c + "," + neighbor.r;

                if (gScore[neighborKey] === undefined || tentativeG < gScore[neighborKey]) {
                    cameFrom[neighborKey] = { c: current.c, r: current.r };
                    gScore[neighborKey] = tentativeG;
                    let f = tentativeG + heuristic(neighbor.c, neighbor.r, endCol, endRow);
                    
                    // Check if neighbor is in openSet
                    let inOpen = openSet.find(n => n.c === neighbor.c && n.r === neighbor.r);
                    if (!inOpen) {
                        openSet.push({ c: neighbor.c, r: neighbor.r, g: tentativeG, f: f });
                    } else {
                        inOpen.g = tentativeG;
                        inOpen.f = f;
                    }
                }
            }
        }
        return []; // No path found
    }

    // --- BFS & MAZE ---
    function getBFSPath(startX, startY, targetX, targetY) {
        let cols = Math.floor(canvas.width/cellSize); let rows = Math.floor(canvas.height/cellSize);
        let sC = Math.floor(startX/cellSize), sR = Math.floor(startY/cellSize);
        let eC = Math.floor(targetX/cellSize), eR = Math.floor(targetY/cellSize);
        if (sC===eC && sR===eR) return [];
        let queue = [{c: sC, r: sR}], cameFrom = {}; cameFrom[sC+","+sR] = null;
        let found = false;
        
        // Safety check bounds
        if(sC<0||sC>=cols||sR<0||sR>=rows||eC<0||eC>=cols||eR<0||eR>=rows) return [];

        let visitedCount = 0;
        while(queue.length > 0) {
            visitedCount++;
            if (visitedCount > 500) break; // Emergency exit

            let cur = queue.shift();
            if (cur.c === eC && cur.r === eR) { found = true; break; }
            let idx = cur.c + cur.r * cols;
            if (idx < 0 || idx >= mazeGrid.length) continue;
            let cell = mazeGrid[idx];
            let neighbors = [];
            if (!cell.w[0]) neighbors.push({c: cur.c, r: cur.r-1}); if (!cell.w[1]) neighbors.push({c: cur.c+1, r: cur.r}); 
            if (!cell.w[2]) neighbors.push({c: cur.c, r: cur.r+1}); if (!cell.w[3]) neighbors.push({c: cur.c-1, r: cur.r}); 
            for (let n of neighbors) {
                if (n.c >= 0 && n.c < cols && n.r >= 0 && n.r < rows) {
                    let key = n.c+","+n.r; if (!(key in cameFrom)) { cameFrom[key] = cur; queue.push(n); }
                }
            }
        }
        if (!found) return [];
        let path = []; let curr = {c: eC, r: eR};
        while (curr) { path.push({x: curr.c, y: curr.r}); curr = cameFrom[curr.c+","+curr.r]; }
        return path.reverse();
    }

    function generateMaze() {
        walls=[]; wallPath=new Path2D(); powerups=[]; activeLasers=[]; tracks=[];
        let cols=Math.floor(canvas.width/cellSize), rows=Math.floor(canvas.height/cellSize);
        let grid=[]; for(let j=0;j<rows;j++) for(let i=0;i<cols;i++) grid.push({i,j,v:false,w:[1,1,1,1]});
        let stack=[], curr=grid[0]; curr.v=true;
        const idx=(i,j)=>(i<0||j<0||i>=cols||j>=rows)?-1:i+j*cols;
        let safeLoop = 0;
        while(safeLoop < 5000){ 
            safeLoop++; let nexts=[], t=grid[idx(curr.i,curr.j-1)], r=grid[idx(curr.i+1,curr.j)], b=grid[idx(curr.i,curr.j+1)], l=grid[idx(curr.i-1,curr.j)];
            if(t&&!t.v)nexts.push({c:t,d:0}); if(r&&!r.v)nexts.push({c:r,d:1}); if(b&&!b.v)nexts.push({c:b,d:2}); if(l&&!l.v)nexts.push({c:l,d:3});
            if(nexts.length){ let n=nexts[Math.floor(Math.random()*nexts.length)]; curr.w[n.d]=0; n.c.w[(n.d+2)%4]=0; stack.push(curr); curr=n.c; curr.v=true; }
            else if(stack.length) curr=stack.pop(); else break;
        }
        for(let j=1; j<rows-1; j++) {
            for(let i=1; i<cols-1; i++) {
                let c = grid[idx(i,j)];
                if (Math.random() < 0.45) {
                    let wallToRemove = Math.floor(Math.random() * 4);
                    if (c.w[wallToRemove] === 1) {
                        c.w[wallToRemove] = 0;
                        if(wallToRemove===0) grid[idx(i,j-1)].w[2]=0; if(wallToRemove===1) grid[idx(i+1,j)].w[3]=0;
                        if(wallToRemove===2) grid[idx(i,j+1)].w[0]=0; if(wallToRemove===3) grid[idx(i-1,j)].w[1]=0;
                    }
                }
            }
        }
        for(let c of grid){
            let x=c.i*cellSize, y=c.j*cellSize;
            const addW=(ax,ay,w,h)=>{ walls.push({x:ax,y:ay,w,h}); wallPath.rect(ax,ay,w,h); };
            let ht=wallThickness/2;
            if(c.w[0]) addW(x-ht, y-ht, cellSize+wallThickness, wallThickness); if(c.w[3]) addW(x-ht, y-ht, wallThickness, cellSize+wallThickness);
            if(c.i===cols-1 && c.w[1]) addW(x+cellSize-ht, y-ht, wallThickness, cellSize+wallThickness); if(c.j===rows-1 && c.w[2]) addW(x-ht, y+cellSize-ht, cellSize+wallThickness, wallThickness);
        }
        let arr=Array.from({length:grid.length},(_,i)=>i); for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
        p1.startX=grid[arr[0]].i*cellSize+cellSize/2; p1.startY=grid[arr[0]].j*cellSize+cellSize/2;
        p2.startX=grid[arr[1]].i*cellSize+cellSize/2; p2.startY=grid[arr[1]].j*cellSize+cellSize/2;
        if(gameMode === 'pve') { p2.isAI = true; p2.name = "MAGIC AI"; } else { p2.isAI = false; p2.name = "P2"; }
        p1.reset(); p2.reset();
        timerSpawnItems = gameSettings.spawnTime * 60; mazeGrid = grid; 
    }

    function spawnPowerUp() {
        if (powerups.length >= gameSettings.maxItems) return;
        let px, py, valid = false; let attempts = 0;
        while(!valid && attempts < 100) { 
            attempts++; px = Math.random() * (canvas.width - 40) + 20; py = Math.random() * (canvas.height - 40) + 20;
            valid = true; for(let w of walls) { if(px > w.x - 20 && px < w.x + w.w + 20 && py > w.y - 20 && py < w.y + w.h + 20) { valid = false; break; } }
        }
        if(valid) powerups.push(new PowerUp(px, py));
    }
    function explodeFrag(x, y, color) { for(let i=0; i<13; i++) { let angle = Math.random() * Math.PI * 2; bullets.push(new Bullet(x, y, angle, color, 'fragment', null)); } createExplosion(x, y, color); createSmoke(x, y); }
    function createHitEffect(x, y, color = '#fff') { 
        particles.push(new Particle(x, y, 'impact_ring', color)); for(let i=0; i<6; i++) particles.push(new Particle(x, y, 'spark', color));
        for(let i=0; i<3; i++) particles.push(new Particle(x, y, 'debris', '#888')); particles.push(new Particle(x, y, 'flash', color));
    }
    function createSparks(x,y,c,n) { for(let i=0;i<n;i++) particles.push(new Particle(x,y,'spark',c)); }
    function createExplosion(x,y,c, big=false) { 
        shakeAmount=35; particles.push(new Particle(x,y,'flash','#fff')); let count = big ? 20 : 10;
        for(let i=0; i<count; i++) particles.push(new Particle(x,y,'fire','#ffaa00')); for(let i=0; i<3; i++) particles.push(new Particle(x,y,'smoke','#888')); 
    }
    function createSmoke(x, y) { for(let i=0;i<2;i++) particles.push(new Particle(x,y,'smoke','#888')); }
    
    function updateAmmoUI(p) {
        if (p.cachedAmmo === p.ammo && p.cachedWeapon === p.weaponType) return;
        p.cachedAmmo = p.ammo; p.cachedWeapon = p.weaponType; const bar=document.getElementById(p.uiId); if(!bar) return; 
        while(bar.firstChild) bar.removeChild(bar.firstChild);
        
        // MODIFIED: UPGRADED UI FOR FLAME (FUEL BAR)
        if (p.weaponType === 'FLAME') {
            const pct = (p.ammo / p.maxAmmo) * 100;
            
            const fuelContainer = document.createElement('div');
            // Container styling
            fuelContainer.style.width = '100px'; // Fixed consistent width
            fuelContainer.style.height = '14px';
            fuelContainer.style.backgroundColor = '#111';
            fuelContainer.style.border = '1px solid #555';
            fuelContainer.style.borderRadius = '3px';
            fuelContainer.style.overflow = 'hidden';
            fuelContainer.style.position = 'relative';
            fuelContainer.style.boxShadow = 'inset 0 0 5px #000';

            const fuelLevel = document.createElement('div');
            // Bar styling
            fuelLevel.style.height = '100%';
            fuelLevel.style.width = pct + '%';
            fuelLevel.style.background = 'linear-gradient(90deg, #ff9800, #ff3d00)'; // Nicer gradient
            fuelLevel.style.boxShadow = '0 0 8px #ff5722';
            fuelLevel.style.transition = 'width 0.1s linear';
            
            // Text Label
            const text = document.createElement('div');
            text.innerText = "FUEL";
            text.style.position = 'absolute';
            text.style.top = '0'; 
            text.style.left = '0'; 
            text.style.width = '100%';
            text.style.height = '100%';
            text.style.display = 'flex';
            text.style.alignItems = 'center';
            text.style.justifyContent = 'center';
            text.style.fontSize = '9px'; 
            text.style.color = '#fff'; 
            text.style.fontWeight = '900'; 
            text.style.textShadow = '0 1px 2px #000';
            text.style.letterSpacing = '1px';
            text.style.zIndex = '2';

            fuelContainer.appendChild(fuelLevel);
            fuelContainer.appendChild(text);
            bar.appendChild(fuelContainer);
        } else {
            // STANDARD AMMO NOTCHES
            for(let i=0;i<p.maxAmmo;i++){ const d=document.createElement('div'); d.className='bullet-notch ' + p.weaponType.toLowerCase(); if(i<p.ammo)d.classList.add('filled'); bar.appendChild(d); }
        }
    }

    // --- DEVICE SELECTION & AUTO FULLSCREEN ---
    function selectDevice(type) {
        isMobile = (type === 'mobile');
        deviceModal.style.display = 'none';
        menu.style.display = 'flex';
        
        if(isMobile) {
            setupMobileControls();
            
            const docEl = document.documentElement;
            if (docEl.requestFullscreen) { docEl.requestFullscreen().catch(() => {}); } 
            else if (docEl.webkitRequestFullscreen) { docEl.webkitRequestFullscreen(); }
            else if (docEl.msRequestFullscreen) { docEl.msRequestFullscreen(); }
            
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(err => console.log("Kh√≥a xoay kh√¥ng kh·∫£ d·ª•ng (b·ªè qua):", err));
            }
        }
    }

    // --- NEW DUAL MOBILE CONTROLS (POINTER EVENTS) ---
    function setupMobileControls() {
        const joyP1 = document.getElementById('joyP1');
        const knobP1 = document.getElementById('knobP1');
        const btnFireP1 = document.getElementById('btnFireP1');
        
        const joyP2 = document.getElementById('joyP2');
        const knobP2 = document.getElementById('knobP2');
        const btnFireP2 = document.getElementById('btnFireP2');

        const maxDist = 30;

        function handleJoystick(e, knob, stateKey) {
            e.preventDefault();
            const rect = e.currentTarget.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            let deltaX = e.clientX - centerX;
            let deltaY = e.clientY - centerY;
            let dist = Math.hypot(deltaX, deltaY);
            
            if (dist > maxDist) {
                let angle = Math.atan2(deltaY, deltaX);
                deltaX = Math.cos(angle) * maxDist;
                deltaY = Math.sin(angle) * maxDist;
            }
            
            knob.style.transform = `translate(-50%, -50%) translate(${deltaX}px, ${deltaY}px)`;
            
            mobileInput[stateKey].x = deltaX / maxDist;
            mobileInput[stateKey].y = deltaY / maxDist;
        }

        function resetJoystick(e, knob, stateKey) {
            e.preventDefault();
            knob.style.transform = `translate(-50%, -50%)`;
            mobileInput[stateKey].x = 0;
            mobileInput[stateKey].y = 0;
        }

        // P1 Listeners
        joyP1.addEventListener('pointerdown', (e) => {
            joyP1.setPointerCapture(e.pointerId);
            handleJoystick(e, knobP1, 'p1');
        });
        joyP1.addEventListener('pointermove', (e) => {
            if (joyP1.hasPointerCapture(e.pointerId)) handleJoystick(e, knobP1, 'p1');
        });
        joyP1.addEventListener('pointerup', (e) => {
            joyP1.releasePointerCapture(e.pointerId);
            resetJoystick(e, knobP1, 'p1');
        });
        joyP1.addEventListener('pointercancel', (e) => resetJoystick(e, knobP1, 'p1'));

        btnFireP1.addEventListener('pointerdown', (e) => { e.preventDefault(); mobileInput.p1.fire = true; btnFireP1.style.background="rgba(46,125,50,0.6)"; });
        btnFireP1.addEventListener('pointerup', (e) => { e.preventDefault(); mobileInput.p1.fire = false; btnFireP1.style.background="rgba(0,0,0,0.05)"; });
        btnFireP1.addEventListener('pointerleave', (e) => { mobileInput.p1.fire = false; btnFireP1.style.background="rgba(0,0,0,0.05)"; });

        // P2 Listeners
        joyP2.addEventListener('pointerdown', (e) => {
            joyP2.setPointerCapture(e.pointerId);
            handleJoystick(e, knobP2, 'p2');
        });
        joyP2.addEventListener('pointermove', (e) => {
            if (joyP2.hasPointerCapture(e.pointerId)) handleJoystick(e, knobP2, 'p2');
        });
        joyP2.addEventListener('pointerup', (e) => {
            joyP2.releasePointerCapture(e.pointerId);
            resetJoystick(e, knobP2, 'p2');
        });
        joyP2.addEventListener('pointercancel', (e) => resetJoystick(e, knobP2, 'p2'));

        btnFireP2.addEventListener('pointerdown', (e) => { e.preventDefault(); mobileInput.p2.fire = true; btnFireP2.style.background="rgba(198,40,40,0.6)"; });
        btnFireP2.addEventListener('pointerup', (e) => { e.preventDefault(); mobileInput.p2.fire = false; btnFireP2.style.background="rgba(0,0,0,0.05)"; });
        btnFireP2.addEventListener('pointerleave', (e) => { mobileInput.p2.fire = false; btnFireP2.style.background="rgba(0,0,0,0.05)"; });
    }

    // --- MENU LOGIC ---
    function hideAllMenus() { menu.style.display = 'none'; settingsModal.style.display = 'none'; guideModal.style.display = 'none'; msgBox.style.display = 'none'; modeModal.style.display='none'; adviceModal.style.display = 'none'; }
    function showModeSelect() { hideAllMenus(); modeModal.style.display = 'flex'; }
    function closeModeSelect() { hideAllMenus(); menu.style.display = 'flex'; }
    
    function selectMode(mode) {
        gameMode = mode; 
        
        const p2Set = document.querySelector('.p2-set');
        const p2NameUI = document.getElementById('p2NameUI');
        const p2Area = document.getElementById('p2ControlArea');
        const p2Header = document.getElementById('p2ControlHeader');

        if(gameMode === 'pve') { 
            if(p2NameUI) p2NameUI.innerText = "MAGIC AI"; 
            if(p2Area) p2Area.style.display = "none";
            if(p2Header) p2Header.style.display = "none";
            if (p2Set) p2Set.style.display = 'none';

        } else { 
            if(p2NameUI) p2NameUI.innerText = "RED PLAYER"; 
            if(p2Area) p2Area.style.display = "block";
            if(p2Header) p2Header.style.display = "block";
            if (p2Set) p2Set.style.display = 'flex';
        }
        
        startGame();

        if (isMobile && screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('landscape').catch(e => console.log("Kh√¥ng th·ªÉ kh√≥a xoay:", e));
        }
    }
    
    function startGame() { 
        hideAllMenus(); 
        triggerAICommentary('start', {}); // Trigger Gemini at start
        if(animationId) cancelAnimationFrame(animationId); gameRunning = true; gamePaused = false; 
        scores = {p1:0, p2:0}; document.getElementById('s1').innerText="0"; document.getElementById('s2').innerText="0"; 
        
        if(isMobile) {
            document.getElementById('mobileControls').style.display = 'block';
        }

        resetRound(); loop(); 
    }
    
    // --- RESTORED: GUIDE RENDER FUNCTION ---
    function renderGuideContent() {
        const container = document.querySelector('.guide-content');
        if(!container) return;
        container.innerHTML = '';
        
        Object.keys(WEAPONS).forEach(key => {
            if(key === 'NORMAL') return;
            const w = WEAPONS[key];
            
            const item = document.createElement('div');
            item.className = 'guide-item';
            
            const iconBox = document.createElement('div');
            iconBox.className = 'guide-icon-box';
            
            const cvs = document.createElement('canvas');
            cvs.width = 50;
            cvs.height = 50;
            
            const ctx = cvs.getContext('2d');
            ctx.translate(25, 25);
            ctx.scale(1.5, 1.5);
            drawItem(ctx, key);
            
            iconBox.appendChild(cvs);
            
            const textBox = document.createElement('div');
            textBox.className = 'guide-text';
            const desc = w.desc ? w.desc : "V≈© kh√≠ ƒë·∫∑c bi·ªát.";
            textBox.innerHTML = `<h4 style="color:${w.color}">${key}</h4><p>${desc}</p>`;
            
            item.appendChild(iconBox);
            item.appendChild(textBox);
            container.appendChild(item);
        });
    }

    function openGuide() { hideAllMenus(); guideModal.style.display = 'flex'; renderGuideContent(); }
    function closeGuide() { hideAllMenus(); menu.style.display = 'flex'; }
    
    // --- UPDATED SETTINGS LOGIC ---
    function openSettings() { 
        if(!gameRunning) return; 
        gamePaused = true; 
        hideAllMenus(); 
        renderWeaponSettings(); 
        
        const controlPanel = document.getElementById('controlsPanelContent');
        if (isMobile) {
            renderMobileSettings(controlPanel);
        } else {
            renderPCControls(controlPanel);
        }

        settingsModal.style.display = 'flex'; 
    }

    function renderMobileSettings(container) {
        let html = `
            <div class="panel-header">MOBILE CONFIG</div>
            <div style="padding: 0 5px;">
                <div class="control-group p1">
                    <div class="sub-header" style="color:#66bb6a; border:none; margin-top:0;">PLAYER 1</div>
                    <div class="custom-row">
                        <div class="custom-label">Sensitivity (Turn Speed) <span id="valSensP1">${mobileSettings.p1.sensitivity.toFixed(1)}</span></div>
                        <input type="range" min="0.5" max="3.0" step="0.1" value="${mobileSettings.p1.sensitivity}" class="custom-range" oninput="window.updateMobileConfig('p1', 'sensitivity', this.value)">
                    </div>
                    <div class="custom-row">
                        <div class="custom-label">Button Size <span id="valSizeP1">${mobileSettings.p1.size}%</span></div>
                        <input type="range" min="50" max="150" step="5" value="${mobileSettings.p1.size}" class="custom-range" oninput="window.updateMobileConfig('p1', 'size', this.value)">
                    </div>
                    <div class="custom-row">
                        <div class="custom-label">Swap Joystick/Fire</div>
                        <input type="checkbox" ${mobileSettings.p1.swap ? 'checked' : ''} onchange="window.updateMobileConfig('p1', 'swap', this.checked)">
                    </div>
                </div>
        `;

        if (gameMode !== 'pve') {
            html += `
                <div class="control-group p2">
                    <div class="sub-header" style="color:#ef5350; border:none; margin-top:0;">PLAYER 2</div>
                    <div class="custom-row">
                        <div class="custom-label">Sensitivity (Turn Speed) <span id="valSensP2">${mobileSettings.p2.sensitivity.toFixed(1)}</span></div>
                        <input type="range" min="0.5" max="3.0" step="0.1" value="${mobileSettings.p2.sensitivity}" class="custom-range" oninput="window.updateMobileConfig('p2', 'sensitivity', this.value)">
                    </div>
                    <div class="custom-row">
                        <div class="custom-label">Button Size <span id="valSizeP2">${mobileSettings.p2.size}%</span></div>
                        <input type="range" min="50" max="150" step="5" value="${mobileSettings.p2.size}" class="custom-range" oninput="window.updateMobileConfig('p2', 'size', this.value)">
                    </div>
                    <div class="custom-row">
                        <div class="custom-label">Swap Joystick/Fire</div>
                        <input type="checkbox" ${mobileSettings.p2.swap ? 'checked' : ''} onchange="window.updateMobileConfig('p2', 'swap', this.checked)">
                    </div>
                </div>
            `;
        } else {
            html += `<div class="control-group p2" style="opacity:0.7;"><div class="sub-header" style="color:#ef5350; border:none; margin:0;">PLAYER 2 (AI)</div><div style="font-size:10px; color:#aaa; margin-top:5px;">Controlled by Magic AI</div></div>`;
        }

        html += `</div>`;
        container.innerHTML = html;
    }

    function renderPCControls(container) {
        let html = `
            <div class="panel-header">CONTROLS CONFIG</div>
            <div style="padding: 0 5px;">
                <div class="control-group p1">
                    <div class="sub-header" style="color:#66bb6a; border:none; margin-top:0;">PLAYER 1 (Green)</div>
                    <div class="key-grid">
                        <span class="key-label">Move Up</span> <button class="key-btn" onclick="window.remap(this, 'p1', 'up')">${controls.p1.up}</button>
                        <span class="key-label">Move Down</span> <button class="key-btn" onclick="window.remap(this, 'p1', 'down')">${controls.p1.down}</button>
                        <span class="key-label">Move Left</span> <button class="key-btn" onclick="window.remap(this, 'p1', 'left')">${controls.p1.left}</button>
                        <span class="key-label">Move Right</span> <button class="key-btn" onclick="window.remap(this, 'p1', 'right')">${controls.p1.right}</button>
                        <div class="key-label" style="color:#fff; margin-top:5px;">FIRE SHOT</div> <button class="key-btn fire" onclick="window.remap(this, 'p1', 'shoot')">${controls.p1.shoot}</button>
                    </div>
                </div>
        `;

        if (gameMode !== 'pve') {
            html += `
                <div class="control-group p2">
                    <div class="sub-header" style="color:#ef5350; border:none; margin-top:0;">PLAYER 2 (Red)</div>
                    <div class="key-grid">
                        <span class="key-label">Move Up</span> <button class="key-btn" onclick="window.remap(this, 'p2', 'up')">${controls.p2.up}</button>
                        <span class="key-label">Move Down</span> <button class="key-btn" onclick="window.remap(this, 'p2', 'down')">${controls.p2.down}</button>
                        <span class="key-label">Move Left</span> <button class="key-btn" onclick="window.remap(this, 'p2', 'left')">${controls.p2.left}</button>
                        <span class="key-label">Move Right</span> <button class="key-btn" onclick="window.remap(this, 'p2', 'right')">${controls.p2.right}</button>
                        <div class="key-label" style="color:#fff; margin-top:5px;">FIRE SHOT</div> <button class="key-btn fire" onclick="window.remap(this, 'p2', 'shoot')">${controls.p2.shoot}</button>
                    </div>
                </div>
            `;
        } else {
            html += `<div class="control-group p2" style="opacity:0.7;"><div class="sub-header" style="color:#ef5350; border:none; margin:0;">PLAYER 2 (AI)</div><div style="font-size:10px; color:#aaa; margin-top:5px;">Controlled by Magic AI</div></div>`;
        }
        
        html += `</div>`;
        container.innerHTML = html;
    }

    function updateMobileConfig(player, type, value) {
        if (type === 'swap') {
            mobileSettings[player].swap = value;
            const setEl = document.querySelector(`.${player}-set`);
            if(setEl) {
                if(value) setEl.classList.add('swapped');
                else setEl.classList.remove('swapped');
            }
        } else {
            value = parseFloat(value);
            if (type === 'sensitivity') {
                mobileSettings[player].sensitivity = value;
                document.getElementById(`valSens${player === 'p1' ? 'P1' : 'P2'}`).innerText = value.toFixed(1);
            } else if (type === 'size') {
                mobileSettings[player].size = value;
                document.getElementById(`valSize${player === 'p1' ? 'P1' : 'P2'}`).innerText = value + '%';
                const scale = value / 100;
                const setEl = document.querySelector(`.${player}-set`);
                if(setEl) setEl.style.transform = `scale(${scale})`;
            }
        }
    }

    function closeSettings() { hideAllMenus(); gamePaused = false; remapping = null; }
    function restartMatch() { scores = { p1: 0, p2: 0 }; document.getElementById('s1').innerText="0"; document.getElementById('s2').innerText="0"; closeSettings(); startGame(); }
    function quitToMenu() { 
        if(animationId) cancelAnimationFrame(animationId); 
        gameRunning=false; gamePaused=false; 
        hideAllMenus(); 
        document.getElementById('mobileControls').style.display = 'none'; 
        menu.style.display='flex'; 
        ctx.clearRect(0,0,canvas.width,canvas.height); 
        roundEnding=false; if(roundEndTimer) clearTimeout(roundEndTimer); 
    }
    
    function updateCustom(el, type, weaponKey) {
        let val = parseInt(el.value); if (isNaN(val)) val = 0; if (val < 0) val = 0; if (val > 100) val = 100;
        if (type === 'time') { gameSettings.spawnTime = val; document.getElementById('valSpawnTime').innerText = val + 's'; if (timerSpawnItems > val * 60) timerSpawnItems = val * 60; } 
        else if (type === 'max') { gameSettings.maxItems = val; document.getElementById('valMaxItems').innerText = val; } 
        else if (type === 'weaponWeight' || type === 'weaponWeightInput') { 
            pendingWeights[weaponKey] = val; document.getElementById('slider_' + weaponKey).value = val; document.getElementById('input_' + weaponKey).value = val; validateTotalDropRate(); 
        }
    }
    function validateTotalDropRate() {
        let total = 0; POWERUP_TYPES.forEach(key => total += pendingWeights[key]);
        const statusDiv = document.getElementById('totalDropRate'); const btn = document.getElementById('btnApplyRates');
        if (total === 100) { statusDiv.innerText = "TOTAL: 100% (VALID)"; statusDiv.style.color = "#4CAF50"; btn.classList.remove("invalid"); btn.classList.add("valid"); btn.disabled = false; btn.innerText = "APPLY CHANGES"; } 
        else { statusDiv.innerText = `TOTAL: ${total}% (MUST BE 100%)`; statusDiv.style.color = "#d32f2f"; btn.classList.remove("valid"); btn.classList.add("invalid"); btn.disabled = true; btn.innerText = "INVALID TOTAL"; }
    }
    function applyDropRates() { POWERUP_TYPES.forEach(key => { WEAPONS[key].weight = pendingWeights[key]; }); document.getElementById('btnApplyRates').innerText = "SAVED!"; }
    
    function remap(btn, player, action) { if (remapping) return; btn.innerText = "..."; btn.classList.add("listening"); remapping = { btn, player, action }; }
    function toggleFS(){ if(!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{}); else if(document.exitFullscreen) document.exitFullscreen(); }
    
    function resetRound() { 
        bullets=[]; particles=[]; powerups=[]; activeLasers=[]; 
        msgBox.style.display="none"; roundEnding=false; 
        if(roundEndTimer) clearTimeout(roundEndTimer); 
        p1.activeShield = false; p2.activeShield = false; 
        tracks = []; 
        bgCtx.clearRect(0, 0, canvas.width, canvas.height); 
        generateMaze(); 
    }
    
    function loop() {
        animationId = requestAnimationFrame(loop); if(gamePaused) return;
        let dx=0, dy=0; if(shakeAmount>0){ dx=(Math.random()-0.5)*shakeAmount; dy=(Math.random()-0.5)*shakeAmount; shakeAmount*=0.9; if(shakeAmount<0.5)shakeAmount=0; }
        
        ctx.save(); ctx.translate(dx,dy); ctx.clearRect(-dx,-dy,canvas.width,canvas.height); ctx.fillStyle="#444"; ctx.fill(wallPath);
        
        bgCtx.clearRect(0, 0, canvas.width, canvas.height); 
        for(let i=tracks.length-1; i>=0; i--) {
            let t = tracks[i]; t.update(); t.draw(bgCtx);
            if (t.life <= 0) tracks.splice(i, 1);
        }

        timerSpawnItems--; if(timerSpawnItems <= 0) { spawnPowerUp(); timerSpawnItems = gameSettings.spawnTime * 60; }
        for(let p of powerups) p.draw();
        for(let b of bullets) { if(b.type === 'mine') b.draw(); }
        for(let i=activeLasers.length-1; i>=0; i--) { let l = activeLasers[i]; l.update(); l.draw(); if(!l.active) activeLasers.splice(i, 1); }
        
        p1.update(walls, powerups); p1.draw(); updateAmmoUI(p1);
        if (p2.isAI) updateAI(p2, p1); p2.update(walls, powerups); p2.draw(); updateAmmoUI(p2);
        
        for(let i=bullets.length-1; i>=0; i--){
            let b=bullets[i]; b.update(walls); if(b.type !== 'mine') b.draw(); 
            if(!b.dead){ 
                if(!p1.dead && circleRectCollide(b.x,b.y,b.radius,p1.x-9,p1.y-9,18,18) && b.owner!==p1){ if(b.type!=='mini') b.dead=true; p1.takeDamage(b.owner, b); }
                else if(!p2.dead && circleRectCollide(b.x,b.y,b.radius,p2.x-9,p2.y-9,18,18) && b.owner!==p2){ if(b.type!=='mini') b.dead=true; p2.takeDamage(b.owner, b); }
            }
            if(!b.dead && b.type==='fragment') {
                 if(!p1.dead && circleRectCollide(b.x,b.y,b.radius,p1.x-9,p1.y-9,18,18)) { b.dead=true; p1.takeDamage(null, b); }
                 if(!p2.dead && circleRectCollide(b.x,b.y,b.radius,p2.x-9,p2.y-9,18,18)) { b.dead=true; p2.takeDamage(null, b); }
            }
            if(!b.dead && b.life<460) {
                 if(!p1.dead && circleRectCollide(b.x,b.y,b.radius,p1.x-9,p1.y-9,18,18)) { b.dead=true; p1.takeDamage(null, b); }
                 if(!p2.dead && circleRectCollide(b.x,b.y,b.radius,p2.x-9,p2.y-9,18,18)) { b.dead=true; p2.takeDamage(null, b); }
            }
            if(b.dead) bullets.splice(i,1);
        }
        for(let i=particles.length-1;i>=0;i--){ let p=particles[i]; p.update(); p.draw(); if(p.life<=0) particles.splice(i,1); }
        ctx.restore();
    }
    

    // --- EXPOSE FUNCTIONS TO WINDOW SCOPE ---
    window.selectDevice = selectDevice;
    window.selectMode = selectMode;
    window.openGuide = openGuide;
    window.closeGuide = closeGuide;
    window.openSettings = openSettings;
    window.closeSettings = closeSettings;
    window.restartMatch = restartMatch;
    window.quitToMenu = quitToMenu;
    window.updateCustom = updateCustom;
    window.applyDropRates = applyDropRates;
    window.showModeSelect = showModeSelect;
    window.closeModeSelect = closeModeSelect;
    window.cycleAI = cycleAI;
    window.remap = remap;
    window.toggleFS = toggleFS;
    window.updateMobileConfig = updateMobileConfig;
    window.askGeminiAdvice = askGeminiAdvice;
    window.closeAdvice = closeAdvice;

    // --- INIT ---
    p1 = new Tank(0,0,"#4CAF50","P1",null,'ammo-p1'); p2 = new Tank(0,0,"#D32F2F","P2",null,'ammo-p2'); 
    
    window.addEventListener('keydown', e => { 
        if (remapping) { e.preventDefault(); controls[remapping.player][remapping.action] = e.code; remapping.btn.innerText = e.code; remapping.btn.classList.remove("listening"); remapping = null; return; }
        keys[e.code] = true; 
        if(e.code==='Escape') { if(gameRunning && !gamePaused) openSettings(); else if(gamePaused) closeSettings(); else if(!document.fullscreenElement) toggleFS(); }
        if(e.code==='KeyF') if(!document.fullscreenElement) toggleFS();
        if(gameRunning && !gamePaused) { if(e.code===controls.p1.shoot && !isMobile) p1.shoot(walls); if(!p2.isAI && e.code===controls.p2.shoot && !isMobile) p2.shoot(walls); }
    });
    window.addEventListener('keyup', e => keys[e.code] = false);
</script>
</body>
</html>